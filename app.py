# -*- coding: utf-8 -*-
from flask import Flask, jsonify, request, send_from_directory,session
from flask_cors import CORS
import os, csv, json, shutil, glob, io, time
from datetime import datetime,timedelta, date
from urllib.parse import unquote
import requests
# from io import BytesIO
import base64, re, math, uuid
# from werkzeug.utils import secure_filename

import hashlib
import jwt
import bcrypt
from functools import wraps
import threading
# from dotenv import load_dotenv


# 初始化Flask应用（必须在所有使用app的代码之前）
app = Flask(__name__)
CORS(app, resources={
    r"/api/*": {"origins": "*"},
    r"/files/images/*": {"origins": "*"}
})
app.config['JSON_AS_ASCII'] = False
app.url_map.charset = 'utf-8'
app.config['JSONIFY_PRETTYPRINT_REGULAR'] = True


# 加载 .env 文件
# load_dotenv()

# 环境检测
# def get_app_config():
#     env = os.environ.get('FLASK_ENV', 'production')
#     debug = os.environ.get('FLASK_DEBUG', 'False').lower() == 'true'
#
#     print(f"应用环境: {env}")
#     print(f"调试模式: {debug}")
#
#     return env, debug


def validate_jwt_secret():
    """验证 JWT 密钥配置"""
    jwt_secret = os.environ.get('JWT_SECRET')
    if not jwt_secret:
        if os.environ.get('FLASK_ENV') == 'production':
            raise ValueError("生产环境必须设置 JWT_SECRET 环境变量")
        else:
            # 开发环境生成临时密钥
            import secrets
            jwt_secret = secrets.token_urlsafe(32)
            print("警告: 使用临时 JWT 密钥，生产环境必须设置 JWT_SECRET")
    return jwt_secret

# JWT配置
#JWT_SECRET = os.environ.get('JWT_SECRET', 'jwt-secret-key-in-production-for-glifeist')

JWT_SECRET = validate_jwt_secret()
JWT_ALGORITHM = 'HS256'
JWT_ACCESS_EXPIRATION_DELTA = timedelta(minutes=120)
JWT_REFRESH_EXPIRATION_DELTA = timedelta(days=7)
JWT_LONG_TERM_EXPIRATION_DELTA = timedelta(days=14)

# safe_save时检查数据完整性参数
MAX_DIFFERENT_FIELDS=2
MAX_DIFFERENT_ITEMS_PER_FIELD=10

# 备份配置
_last_backup_time = None
_backup_interval = 300  # 5分钟间隔
_max_backups = 10  # 最多保留10个备份


default_tasks = []
_settings_cache = None
_executing_auto_tasks = False # 添加一个全局变量来防止递归调用


# 用户数据目录
USERS_DIR = 'users'
USERS_DB_FILE = os.path.join(USERS_DIR, 'users.json')
DEFAULT_DATA_FILES = ['settings.json', 'logs.json', 'master_data.json']


default_settings = {
    "allowFormulasEditing": False,
    "allowManualCreditEditing": False,
    "boardViewSettings": {
        "maxCardWidth": 300,
        "maxDescriptionLength": 70,
        "maxTagLength": 30
    },
    "moduleOrder": ["面板", "任务","背包", "商店", "道具", "工坊", "笔记", "日志", "设置"],
    "itemCategories": ["经验类", "属性类", "消耗类", "装备类", "材料类", "任务类", "宝箱类", "实物类", "其它类"],
    "taskCategories": ["主线任务", "辅线任务", "支线任务", "特殊任务"],
    "taskPriorities": ["重要且紧急", "重要不紧急", "不重要但紧急", "不重要不紧急"],
    "taskDomains": ["学习", "工作", "运动", "生活", "社交", "内修"],
    "creditTypes": ["水晶", "星钻", "魂玉", "骨贝", "源石", "灵石", "金币", "元宝"],
    "taskStatuses": ["未完成", "进行中", "重复中", "已完成"],
    "propertyCategories": ['智力','力量', '体质', '活力', '敏捷', '灵力'],  # 默认属性类别
    # "characterSettings": [],  # 角色设置：积分类型、任务领域与属性类别的映射关系

    "taskCycleTypes": [
        "无循环",
        "日循环",
        "周循环",
        "月循环",
        "年循环"
    ],

    "borderSettings": {
        "bottom": {
            "colors": {
                "不重要不紧急": "#364805",
                "不重要但紧急": "#803e00",
                "主线任务": "#e91616",
                "学习": "#cf432a",
                "工作": "#f00000",
                "已完成": "#0ba245",
                "支线任务": "#82f014",
                "未完成": "#f4c10b",
                "特殊任务": "#3127b4",
                "生活": "#f4c10b",
                "社交": "#0ba245",
                "内修": "#09a4f1",
                "辅线任务": "#f4c10b",
                "运动": "#fa6400",
                "进行中": "#f00000",
                "重复中": "#fa6400",
                "重要不紧急": "#910808",
                "重要且紧急": "#8e0490"
            },
            "enabled": {
                "board": True,
                "calendar": False
            },
            "field": "status"
        },
        "left": {
            "colors": {
                "不重要不紧急": "#364805",
                "不重要但紧急": "#803e00",
                "主线任务": "#f00000",
                "学习": "#cf432a",
                "工作": "#f00000",
                "已完成": "#0ba245",
                "支线任务": "#0ba245",
                "未完成": "#f4c10b",
                "特殊任务": "#09a4f1",
                "生活": "#f4c10b",
                "社交": "#0ba245",
                "内修": "#09a4f1",
                "辅线任务": "#f4c10b",
                "运动": "#fa6400",
                "进行中": "#f00000",
                "重复中": "#fa6400",
                "重要不紧急": "#910808",
                "重要且紧急": "#8e0490"
            },
            "enabled": {
                "board": True,
                "calendar": False
            },
            "field": "priority"
        },
        "right": {
            "colors": {
                "不重要不紧急": "#09a4f1",
                "不重要但紧急": "#0ba245",
                "主线任务": "#e91616",
                "学习": "#dd8383",
                "工作": "#751a1a",
                "已完成": "#0ba245",
                "支线任务": "#82f014",
                "未完成": "#f4c10b",
                "特殊任务": "#3127b4",
                "生活": "#0ba245",
                "社交": "#09a4f1",
                "内修": "#910dd9",
                "辅线任务": "#f4c10b",
                "运动": "#4c7c03",
                "进行中": "#f00000",
                "重复中": "#fa6400",
                "重要不紧急": "#fa6400",
                "重要且紧急": "#f00000"
            },
            "enabled": {
                "board": False,
                "calendar": True
            },
            "field": "category"
        },
        "top": {
            "colors": {
                "不重要不紧急": "#364805",
                "不重要但紧急": "#803e00",
                "主线任务": "#e91616",
                "学习": "#cf432a",
                "工作": "#f00000",
                "支线任务": "#82f014",
                "特殊任务": "#3127b4",
                "生活": "#f4c10b",
                "社交": "#0ba245",
                "内修": "#09a4f1",
                "辅线任务": "#f4c10b",
                "运动": "#fa6400",
                "重要不紧急": "#910808",
                "重要且紧急": "#8e0490"
            },
            "enabled": {
                "board": False,
                "calendar": True
            },
            "field": "domain"
        }
    },
    "calendarViewSettings": {
        "defaultTaskCards": 3,
        "firstDayOfWeek": 1,
        "maxChars": 20,
        "statItems": [
            {
                "fieldType": "category",
                "fieldValue": "主线任务",
                "id": 1761631899393
            },
            {
                "fieldType": "category",
                "fieldValue": "辅线任务",
                "id": 1761631902130
            },
            {
                "fieldType": "credit",
                "fieldValue": "水晶",
                "id": 1761631988467
            },
            {
                "fieldType": "credit",
                "fieldValue": "星钻",
                "id": 1761634506444
            }
        ]
    },
    "characterSettings": [
        {
            "color": "#185ecd",
            "creditIcon": "🔮",
            "creditType": "水晶",
            "domain": "学习",
            "icon": "🧠",
            "propertyCategory": "智力"
        },
        {
            "color": "#ea4335",
            "creditIcon": "💎",
            "creditType": "星钻",
            "domain": "工作",
            "icon": "💪",
            "propertyCategory": "力量"
        },
        {
            "color": "#34a853",
            "creditIcon": "♦️",
            "creditType": "魂玉",
            "domain": "运动",
            "icon": "💔",
            "propertyCategory": "体质"
        },
        {
            "color": "#fbbc05",
            "creditIcon": "🐚",
            "creditType": "骨贝",
            "domain": "生活",
            "icon": "🌿",
            "propertyCategory": "活力"
        },
        {
            "color": "#a142f4",
            "creditIcon": "💫",
            "creditType": "源石",
            "domain": "社交",
            "icon": "🏃",
            "propertyCategory": "敏捷"
        },
        {
            "color": "#21c1c1",
            "creditIcon": "🌟",
            "creditType": "灵石",
            "domain": "内修",
            "icon": "🔥",
            "propertyCategory": "灵力"
        },
        {
            "color": "#666666",
            "creditIcon": "💰",
            "creditType": "金币",
            "domain": "",
            "icon": "",
            "propertyCategory": ""
        },
        {
            "color": "#666666",
            "creditIcon": "💠",
            "creditType": "元宝",
            "domain": "",
            "icon": "",
            "propertyCategory": ""
        }
    ],

    "customDomain": "",
    "defaultHomePage": "/character",
    "defaultParallelWorld": "完美世界",
    "effectConfig": {
        "categories": {
            "主线任务": {
                "animation": "pulse-red",
                "particle": "hearts-pink"
            },
            "支线任务": {
                "animation": "pulse-blue",
                "particle": "confetti-blue"
            },
            "特殊任务": {
                "animation": "pulse-green",
                "particle": "sparkles-green"
            },
            "辅线任务": {
                "animation": "pulse-yellow",
                "particle": "stars-gold"
            },
            "默认": {
                "animation": "pulse-white",
                "particle": "simple-sparkle"
            }
        },
        "domains": {
            "学习": {
                "sound": "02.mp3"
            },
            "工作": {
                "sound": "01.mp3"
            },
            "生活": {
                "sound": "06.mp3"
            },
            "社交": {
                "sound": "04.mp3"
            },
            "内修": {
                "sound": "05.mp3"
            },
            "运动": {
                "sound": "03.mp3"
            },
            "默认": {
                "sound": "07.mp3"
            }
        },
        "priorities": {
            "不重要不紧急": {
                "intensity": 0.5,
                "size": 1.5
            },
            "不重要但紧急": {
                "intensity": 1.2,
                "size": 3.6
            },
            "重要不紧急": {
                "intensity": 1.9,
                "size": 5.7
            },
            "重要且紧急": {
                "intensity": 2.7,
                "size": 8.1
            },
            "默认": {
                "intensity": 1,
                "size": 1
            }
        }
    },
    "enableAllCreditsPricing": False,
    "enableEffectOnTaskCompletion": True,
    "enableEffectParamsEditing": False,
    "enableFloatingControlButton": True,
    "expFormulas": {
        "levelUpA": 100,
        "levelUpN": 3,
        "propertyLevelA": 10,
        "propertyLevelN": 2,
        "taskExpCoefficient": 0.5,
        "taskExpMultiplier": 1
    },
    "fileStorage": {
        "mountPath": "/files"
    },
    "gmCommands": {
        "1760707733522": {
            "description": "刷道具",
            "gameWorld": "完美世界",
            "gmCommand": "d_c2scmd 10800 {item} <count>"
        },
        "1760709337636": {
            "description": "刷怪物",
            "gameWorld": "完美世界",
            "gmCommand": "d_c2scmd 10802 {怪物Id} <怪物个数> 0 0"
        }
    },
    "levelToRealm": [
        {
            "境界": "肉胎凡体",
            "描述": "凡人肉身，未涉仙道，根基初成",
            "结束等级": "9",
            "起始等级": "1"
        },
        {
            "境界": "引气入体",
            "描述": "吸纳天地灵气，开启修仙之门",
            "结束等级": "19",
            "起始等级": "10"
        },
        {
            "境界": "炼气初期",
            "描述": "灵气入脉，初显修真之能",
            "结束等级": "29",
            "起始等级": "20"
        },
        {
            "境界": "炼气中期",
            "描述": "灵气渐厚，体能增强",
            "结束等级": "39",
            "起始等级": "30"
        },
        {
            "境界": "炼气后期",
            "描述": "灵气充盈，为筑基奠基",
            "结束等级": "49",
            "起始等级": "40"
        },
        {
            "境界": "筑基初期",
            "描述": "筑就仙基，脱凡入道",
            "结束等级": "59",
            "起始等级": "50"
        },
        {
            "境界": "筑基中期",
            "描述": "根基稳固，法力初成",
            "结束等级": "69",
            "起始等级": "60"
        },
        {
            "境界": "筑基后期",
            "描述": "根基深厚，迈向结丹",
            "结束等级": "79",
            "起始等级": "70"
        },
        {
            "境界": "结丹初期",
            "描述": "凝聚金丹，寿元大增",
            "结束等级": "89",
            "起始等级": "80"
        },
        {
            "境界": "结丹中期",
            "描述": "金丹圆满，法力质变",
            "结束等级": "99",
            "起始等级": "90"
        },
        {
            "境界": "结丹后期",
            "描述": "金丹凝实，突破在即",
            "结束等级": "109",
            "起始等级": "100"
        },
        {
            "境界": "元婴初期",
            "描述": "化婴成形，神魂独立",
            "结束等级": "119",
            "起始等级": "110"
        },
        {
            "境界": "元婴中期",
            "描述": "元婴茁壮，神通初显",
            "结束等级": "129",
            "起始等级": "120"
        },
        {
            "境界": "元婴后期",
            "描述": "元婴强大，接近化神",
            "结束等级": "139",
            "起始等级": "130"
        },
        {
            "境界": "化神初期",
            "描述": "神魂合一，感悟天地",
            "结束等级": "149",
            "起始等级": "140"
        },
        {
            "境界": "化神中期",
            "描述": "神通广博，法力无边",
            "结束等级": "159",
            "起始等级": "150"
        },
        {
            "境界": "化神后期",
            "描述": "化神圆满，窥探炼虚",
            "结束等级": "169",
            "起始等级": "160"
        },
        {
            "境界": "化神巅峰",
            "描述": "巅峰之境，突破在即",
            "结束等级": "179",
            "起始等级": "170"
        },
        {
            "境界": "炼虚初期",
            "描述": "炼化虚空，超脱凡俗",
            "结束等级": "189",
            "起始等级": "180"
        },
        {
            "境界": "炼虚中期",
            "描述": "虚力掌控，空间自如",
            "结束等级": "199",
            "起始等级": "190"
        },
        {
            "境界": "炼虚后期",
            "描述": "虚境大成，迈向合体",
            "结束等级": "209",
            "起始等级": "200"
        },
        {
            "境界": "炼虚巅峰",
            "描述": "巅峰虚境，质变前夜",
            "结束等级": "219",
            "起始等级": "210"
        },
        {
            "境界": "合体初期",
            "描述": "身与道合，初现法则",
            "结束等级": "229",
            "起始等级": "220"
        },
        {
            "境界": "合体中期",
            "描述": "道体稳固，法力升华",
            "结束等级": "239",
            "起始等级": "230"
        },
        {
            "境界": "合体后期",
            "描述": "合体圆满，接近大乘",
            "结束等级": "249",
            "起始等级": "240"
        },
        {
            "境界": "合体巅峰",
            "描述": "巅峰之境，突破在即",
            "结束等级": "259",
            "起始等级": "250"
        },
        {
            "境界": "大乘初期",
            "描述": "渡劫在望，仙道将成",
            "结束等级": "269",
            "起始等级": "260"
        },
        {
            "境界": "大乘中期",
            "描述": "法力通玄，为飞升准备",
            "结束等级": "279",
            "起始等级": "270"
        },
        {
            "境界": "大乘后期",
            "描述": "大乘圆满，飞升临界",
            "结束等级": "289",
            "起始等级": "280"
        },
        {
            "境界": "大乘巅峰",
            "描述": "巅峰之境，飞升在即",
            "结束等级": "299",
            "起始等级": "290"
        },
        {
            "境界": "真仙初期",
            "描述": "仙体初成，超脱凡界",
            "结束等级": "309",
            "起始等级": "300"
        },
        {
            "境界": "真仙中期",
            "描述": "仙力精进，法则初悟",
            "结束等级": "319",
            "起始等级": "310"
        },
        {
            "境界": "真仙后期",
            "描述": "仙道稳固，迈向金仙",
            "结束等级": "329",
            "起始等级": "320"
        },
        {
            "境界": "真仙巅峰",
            "描述": "巅峰之境，突破在即",
            "结束等级": "339",
            "起始等级": "330"
        },
        {
            "境界": "金仙初期",
            "描述": "金身不朽，神通广大",
            "结束等级": "349",
            "起始等级": "340"
        },
        {
            "境界": "金仙中期",
            "描述": "金仙圆满，法力无边",
            "结束等级": "359",
            "起始等级": "350"
        },
        {
            "境界": "金仙后期",
            "描述": "接近太乙，法则深化",
            "结束等级": "369",
            "起始等级": "360"
        },
        {
            "境界": "金仙巅峰",
            "描述": "巅峰之境，突破前夜",
            "结束等级": "379",
            "起始等级": "370"
        },
        {
            "境界": "太乙初期",
            "描述": "太乙真身，万法不侵",
            "结束等级": "389",
            "起始等级": "380"
        },
        {
            "境界": "太乙中期",
            "描述": "太乙精进，掌控时空",
            "结束等级": "399",
            "起始等级": "390"
        },
        {
            "境界": "太乙后期",
            "描述": "太乙圆满，迈向大罗",
            "结束等级": "409",
            "起始等级": "400"
        },
        {
            "境界": "太乙巅峰",
            "描述": "巅峰之境，突破在即",
            "结束等级": "419",
            "起始等级": "410"
        },
        {
            "境界": "大罗初期",
            "描述": "大罗金身，超脱因果",
            "结束等级": "429",
            "起始等级": "420"
        },
        {
            "境界": "大罗中期",
            "描述": "大罗稳固，法则主宰",
            "结束等级": "439",
            "起始等级": "430"
        },
        {
            "境界": "大罗后期",
            "描述": "大罗圆满，接近道祖",
            "结束等级": "449",
            "起始等级": "440"
        },
        {
            "境界": "大罗巅峰",
            "描述": "巅峰之境，突破前夜",
            "结束等级": "459",
            "起始等级": "450"
        },
        {
            "境界": "道祖初期",
            "描述": "道祖之始，创世之基",
            "结束等级": "469",
            "起始等级": "460"
        },
        {
            "境界": "道祖中期",
            "描述": "道祖精进，法则创生",
            "结束等级": "479",
            "起始等级": "470"
        },
        {
            "境界": "道祖后期",
            "描述": "道祖圆满，掌控本源",
            "结束等级": "489",
            "起始等级": "480"
        },
        {
            "境界": "道祖巅峰",
            "描述": "巅峰之境，至高无上",
            "结束等级": "499",
            "起始等级": "490"
        },
        {
            "境界": "开天辟地",
            "描述": "创世之力，超越一切",
            "结束等级": "999",
            "起始等级": "500"
        }
    ],
    "mainActionButtonSettings": {
        "addTask": "visible",
        "batchDelete": "hidden",
        "exportTasks": "hidden",
        "importTasks": "hidden",
        "quickAddTask": "visible",
        "showCalendarStats": "visible"
    },

    "noteAutoSaveInterval": 7,
    "parallelWorlds": [
        "完美世界",
        "魔兽世界",
        "默认世界"
    ],

    "propertyToRealm": [
        {
            "境界": "未开蒙",
            "描述": "尚未接受启蒙教育，处于学习起步阶段",
            "结束等级": "9",
            "起始等级": "1",
            "领域": "学习"
        },
        {
            "境界": "学前",
            "描述": "入学前儿童，接受基础认知与社交启蒙",
            "结束等级": "19",
            "起始等级": "10",
            "领域": "学习"
        },
        {
            "境界": "小学生",
            "描述": "小学阶段学生，学习基础学科知识",
            "结束等级": "29",
            "起始等级": "20",
            "领域": "学习"
        },
        {
            "境界": "初中生",
            "描述": "初中阶段学生，深化知识体系与能力培养",
            "结束等级": "39",
            "起始等级": "30",
            "领域": "学习"
        },
        {
            "境界": "高中生",
            "描述": "高中阶段学生，备战高考，奠定专业基础",
            "结束等级": "49",
            "起始等级": "40",
            "领域": "学习"
        },
        {
            "境界": "大学生",
            "描述": "大学阶段学生，专攻学科，探索职业方向",
            "结束等级": "59",
            "起始等级": "50",
            "领域": "学习"
        },
        {
            "境界": "学士",
            "描述": "本科毕业获学位，具备专业基础能力",
            "结束等级": "69",
            "起始等级": "60",
            "领域": "学习"
        },
        {
            "境界": "硕士",
            "描述": "研究生毕业获学位，专精领域独立研究",
            "结束等级": "79",
            "起始等级": "70",
            "领域": "学习"
        },
        {
            "境界": "博士",
            "描述": "最高学位获得者，创新研究，贡献学术前沿",
            "结束等级": "89",
            "起始等级": "80",
            "领域": "学习"
        },
        {
            "境界": "博士后",
            "描述": "博士毕业后深造，深化研究，拓展学术视野",
            "结束等级": "99",
            "起始等级": "90",
            "领域": "学习"
        },
        {
            "境界": "助教",
            "描述": "协助教学，辅导学生，积累教学经验",
            "结束等级": "109",
            "起始等级": "100",
            "领域": "学习"
        },
        {
            "境界": "讲师",
            "描述": "独立授课，传授知识，参与学术研究",
            "结束等级": "119",
            "起始等级": "110",
            "领域": "学习"
        },
        {
            "境界": "副教授",
            "描述": "学术骨干，指导研究，承担教学重任",
            "结束等级": "129",
            "起始等级": "120",
            "领域": "学习"
        },
        {
            "境界": "教授",
            "描述": "学术权威，引领学科，培养高层次人才",
            "结束等级": "139",
            "起始等级": "130",
            "领域": "学习"
        },
        {
            "境界": "荣誉教授",
            "描述": "杰出贡献者，获荣誉称号，学术影响力深远",
            "结束等级": "149",
            "起始等级": "140",
            "领域": "学习"
        },
        {
            "境界": "次青",
            "描述": "青年学者新秀，崭露头角，潜力待发",
            "结束等级": "159",
            "起始等级": "150",
            "领域": "学习"
        },
        {
            "境界": "小青",
            "描述": "青年学术骨干，活跃研究，成果初显",
            "结束等级": "169",
            "起始等级": "160",
            "领域": "学习"
        },
        {
            "境界": "大青",
            "描述": "资深青年学者，引领方向，成果显著",
            "结束等级": "179",
            "起始等级": "170",
            "领域": "学习"
        },
        {
            "境界": "次院",
            "描述": "学术机构副职，辅助管理，推动学术发展",
            "结束等级": "189",
            "起始等级": "180",
            "领域": "学习"
        },
        {
            "境界": "院士候选",
            "描述": "院士评选入围者，卓越成就，待终极认可",
            "结束等级": "199",
            "起始等级": "190",
            "领域": "学习"
        },
        {
            "境界": "院士",
            "描述": "学术最高荣誉，国家智库，引领科技创新",
            "结束等级": "999",
            "起始等级": "200",
            "领域": "学习"
        },
        {
            "境界": "学生",
            "描述": "在校学习，积累知识，为未来职业做准备",
            "结束等级": "9",
            "起始等级": "1",
            "领域": "工作"
        },
        {
            "境界": "待业",
            "描述": "暂时无工作，处于求职或职业过渡阶段",
            "结束等级": "19",
            "起始等级": "10",
            "领域": "工作"
        },
        {
            "境界": "实习生",
            "描述": "短期实践，学习技能，积累职场经验",
            "结束等级": "29",
            "起始等级": "20",
            "领域": "工作"
        },
        {
            "境界": "初级员工",
            "描述": "职场新人，执行基础任务，积累经验",
            "结束等级": "39",
            "起始等级": "30",
            "领域": "工作"
        },
        {
            "境界": "中级员工",
            "描述": "经验丰富，独立负责项目，指导新人",
            "结束等级": "49",
            "起始等级": "40",
            "领域": "工作"
        },
        {
            "境界": "高级员工",
            "描述": "资深专家，主导复杂任务，提供专业建议",
            "结束等级": "59",
            "起始等级": "50",
            "领域": "工作"
        },
        {
            "境界": "主管",
            "描述": "管理小团队，分配任务，监督日常运营",
            "结束等级": "69",
            "起始等级": "60",
            "领域": "工作"
        },
        {
            "境界": "高级主管",
            "描述": "领导部门，制定策略，协调跨团队合作",
            "结束等级": "79",
            "起始等级": "70",
            "领域": "工作"
        },
        {
            "境界": "副经理",
            "描述": "协助经理，参与决策，管理关键项目",
            "结束等级": "89",
            "起始等级": "80",
            "领域": "工作"
        },
        {
            "境界": "经理",
            "描述": "负责部门，规划目标，优化工作流程",
            "结束等级": "99",
            "起始等级": "90",
            "领域": "工作"
        },
        {
            "境界": "高级经理",
            "描述": "领导多团队，推动战略，提升部门绩效",
            "结束等级": "109",
            "起始等级": "100",
            "领域": "工作"
        },
        {
            "境界": "副总监",
            "描述": "支持总监，统筹业务，确保目标达成",
            "结束等级": "119",
            "起始等级": "110",
            "领域": "工作"
        },
        {
            "境界": "总监",
            "描述": "管理业务线，制定政策，驱动公司增长",
            "结束等级": "129",
            "起始等级": "120",
            "领域": "工作"
        },
        {
            "境界": "高级总监",
            "描述": "领导核心领域，创新策略，影响公司方向",
            "结束等级": "139",
            "起始等级": "130",
            "领域": "工作"
        },
        {
            "境界": "副总裁",
            "描述": "高层领导，分管业务，参与公司决策",
            "结束等级": "149",
            "起始等级": "140",
            "领域": "工作"
        },
        {
            "境界": "小股东",
            "描述": "持有少量股份，对公司有一定影响力",
            "结束等级": "159",
            "起始等级": "150",
            "领域": "工作"
        },
        {
            "境界": "高级副总裁",
            "描述": "核心高管，负责战略，推动公司发展",
            "结束等级": "169",
            "起始等级": "160",
            "领域": "工作"
        },
        {
            "境界": "大股东",
            "描述": "主要股份持有者，对公司有重大影响力",
            "结束等级": "179",
            "起始等级": "170",
            "领域": "工作"
        },
        {
            "境界": "总裁",
            "描述": "公司最高执行者，全面管理运营",
            "结束等级": "189",
            "起始等级": "180",
            "领域": "工作"
        },
        {
            "境界": "控股股东",
            "描述": "控股企业，主导公司重大决策",
            "结束等级": "199",
            "起始等级": "190",
            "领域": "工作"
        },
        {
            "境界": "董事长",
            "描述": "董事会领导者，制定公司长远愿景",
            "结束等级": "999",
            "起始等级": "200",
            "领域": "工作"
        },
        {
            "境界": "懒癌级",
            "描述": "无运动，除了吃就是睡",
            "结束等级": "9",
            "起始等级": "1",
            "领域": "运动"
        },
        {
            "境界": "久坐级",
            "描述": "每日运动＜10 分钟，常久坐不动",
            "结束等级": "19",
            "起始等级": "10",
            "领域": "运动"
        },
        {
            "境界": "微动级",
            "描述": "每日散步＜20 分钟，仅偶尔起身活动",
            "结束等级": "29",
            "起始等级": "20",
            "领域": "运动"
        },
        {
            "境界": "起步级",
            "描述": "每周 1 次散步，每次 30 分钟左右",
            "结束等级": "39",
            "起始等级": "30",
            "领域": "运动"
        },
        {
            "境界": "适应级",
            "描述": "每周 2 次轻度运动，如慢走、拉伸",
            "结束等级": "49",
            "起始等级": "40",
            "领域": "运动"
        },
        {
            "境界": "基础级",
            "描述": "每周 3 次 30 分钟快走，能持续完成",
            "结束等级": "59",
            "起始等级": "50",
            "领域": "运动"
        },
        {
            "境界": "入门级",
            "描述": "每周 3 次低强度有氧，如慢跑、瑜伽",
            "结束等级": "69",
            "起始等级": "60",
            "领域": "运动"
        },
        {
            "境界": "稳定级",
            "描述": "每周 4 次中等强度运动，每次 40 分钟",
            "结束等级": "79",
            "起始等级": "70",
            "领域": "运动"
        },
        {
            "境界": "进阶级",
            "描述": "每周 4 次有氧 + 1 次力量训练，有固定计划",
            "结束等级": "89",
            "起始等级": "80",
            "领域": "运动"
        },
        {
            "境界": "提升级",
            "描述": "每周 5 次运动，含有氧、力量、柔韧性训练",
            "结束等级": "99",
            "起始等级": "90",
            "领域": "运动"
        },
        {
            "境界": "达标级",
            "描述": "运动达标 WHO 推荐量，体能明显改善",
            "结束等级": "109",
            "起始等级": "100",
            "领域": "运动"
        },
        {
            "境界": "精进阶",
            "描述": "有专项运动方向，如跑步、游泳，能完成进阶动作",
            "结束等级": "119",
            "起始等级": "110",
            "领域": "运动"
        },
        {
            "境界": "专长级",
            "描述": "某类运动熟练，如能跑 5 公里、完成进阶瑜伽体式",
            "结束等级": "129",
            "起始等级": "120",
            "领域": "运动"
        },
        {
            "境界": "业余级",
            "描述": "每周系统训练 6 次，能参加业余运动赛事",
            "结束等级": "139",
            "起始等级": "130",
            "领域": "运动"
        },
        {
            "境界": "高手级",
            "描述": "在业余赛事中取得较好成绩，运动技巧专精",
            "结束等级": "149",
            "起始等级": "140",
            "领域": "运动"
        },
        {
            "境界": "准专业",
            "描述": "接受半专业训练，有明确运动目标与周期计划",
            "结束等级": "159",
            "起始等级": "150",
            "领域": "运动"
        },
        {
            "境界": "专业级",
            "描述": "全职训练，具备参加职业赛事的能力",
            "结束等级": "169",
            "起始等级": "160",
            "领域": "运动"
        },
        {
            "境界": "精英级",
            "描述": "在职业赛事中稳定发挥，进入行业中上游",
            "结束等级": "179",
            "起始等级": "170",
            "领域": "运动"
        },
        {
            "境界": "顶尖级",
            "描述": "能在全国性职业赛事中夺冠，运动水平国内领先",
            "结束等级": "189",
            "起始等级": "180",
            "领域": "运动"
        },
        {
            "境界": "大师级",
            "描述": "在国际赛事中取得优异成绩，行业内有影响力",
            "结束等级": "199",
            "起始等级": "190",
            "领域": "运动"
        },
        {
            "境界": "传奇级",
            "描述": "运动成就享誉全球，对该领域有突破性贡献",
            "结束等级": "999",
            "起始等级": "200",
            "领域": "运动"
        },
        {
            "境界": "沿街行乞",
            "描述": "不得温饱，衣不蔽体，栖身街头，步行代步",
            "结束等级": "9",
            "起始等级": "1",
            "领域": "生活"
        },
        {
            "境界": "果腹蔽体",
            "描述": "仅满足温饱；遮身保暖；临时栖身；步行代步",
            "结束等级": "19",
            "起始等级": "10",
            "领域": "生活"
        },
        {
            "境界": "基础保障",
            "描述": "三餐规律；应季整洁；简易单间；共享单车",
            "结束等级": "29",
            "起始等级": "20",
            "领域": "生活"
        },
        {
            "境界": "日常温饱",
            "描述": "荤素搭配；基础品牌；合租次卧；公交地铁",
            "结束等级": "39",
            "起始等级": "30",
            "领域": "生活"
        },
        {
            "境界": "便利舒适",
            "描述": "外卖任选；款式多样；整租一居；短途打车",
            "结束等级": "49",
            "起始等级": "40",
            "领域": "生活"
        },
        {
            "境界": "品质入门",
            "描述": "连锁餐厅；轻奢单品；两居公寓；自驾代步",
            "结束等级": "59",
            "起始等级": "50",
            "领域": "生活"
        },
        {
            "境界": "精致生活",
            "描述": "私房菜馆；设计师品牌；精装住宅；商务租车",
            "结束等级": "69",
            "起始等级": "60",
            "领域": "生活"
        },
        {
            "境界": "轻奢享受",
            "描述": "米其林推荐；高端成衣；花园洋房；豪华轿车",
            "结束等级": "79",
            "起始等级": "70",
            "领域": "生活"
        },
        {
            "境界": "品质进阶",
            "描述": "星级餐厅；定制西装；联排别墅；高端 SUV",
            "结束等级": "89",
            "起始等级": "80",
            "领域": "生活"
        },
        {
            "境界": "高端体验",
            "描述": "私厨上门；高定礼服；独栋别墅；豪华跑车",
            "结束等级": "99",
            "起始等级": "90",
            "领域": "生活"
        },
        {
            "境界": "奢华入门",
            "描述": "米其林三星；奢侈品套装；湖景别墅；私人轿车",
            "结束等级": "109",
            "起始等级": "100",
            "领域": "生活"
        },
        {
            "境界": "尊享生活",
            "描述": "全球美食宴；限量奢侈品；城市豪宅；商务座驾",
            "结束等级": "119",
            "起始等级": "110",
            "领域": "生活"
        },
        {
            "境界": "奢华进阶",
            "描述": "私人营养师配餐；高定奢侈品；半山别墅；定制豪车",
            "结束等级": "129",
            "起始等级": "120",
            "领域": "生活"
        },
        {
            "境界": "顶奢体验",
            "描述": "米其林主厨定制；高级定制时装；海景庄园；超跑收藏",
            "结束等级": "139",
            "起始等级": "130",
            "领域": "生活"
        },
        {
            "境界": "专属定制",
            "描述": "私人厨师专属；私人定制华服；定制别墅；私人游艇",
            "结束等级": "149",
            "起始等级": "140",
            "领域": "生活"
        },
        {
            "境界": "稀缺尊享",
            "描述": "稀缺食材宴；限量高定；城市稀缺豪宅；私人飞机短途",
            "结束等级": "159",
            "起始等级": "150",
            "领域": "生活"
        },
        {
            "境界": "顶级私享",
            "描述": "全球稀缺食材定制；独家高定；私人庄园；私人飞机",
            "结束等级": "169",
            "起始等级": "160",
            "领域": "生活"
        },
        {
            "境界": "圈层专属",
            "描述": "圈层私宴；顶级设计师专属；定制庄园；私人飞机",
            "结束等级": "179",
            "起始等级": "170",
            "领域": "生活"
        },
        {
            "境界": "传世奢享",
            "描述": "家族私厨传承；传世定制华服；传世豪宅；私人飞机 + 游艇",
            "结束等级": "189",
            "起始等级": "180",
            "领域": "生活"
        },
        {
            "境界": "巅峰定制",
            "描述": "全球顶级私厨定制；殿堂级高定；巅峰豪宅；私人专机 + 豪华游艇",
            "结束等级": "199",
            "起始等级": "190",
            "领域": "生活"
        },
        {
            "境界": "终极尊享",
            "描述": "全球专属稀缺食材；独家传世定制；顶奢庄园；私人专机+豪华游艇+专属列车",
            "结束等级": "999",
            "起始等级": "200",
            "领域": "生活"
        },
        {
            "境界": "隐世级",
            "描述": "零社交，对社交场合感到强烈恐惧或忧虑",
            "结束等级": "9",
            "起始等级": "1",
            "领域": "社交"
        },
        {
            "境界": "回避级",
            "描述": "刻意避开社交场景，面对陌生人会紧张到无法开口",
            "结束等级": "19",
            "起始等级": "10",
            "领域": "社交"
        },
        {
            "境界": "被动级",
            "描述": "仅在他人主动搭话时回应，且多为 “是 / 不是” 等简短答案",
            "结束等级": "29",
            "起始等级": "20",
            "领域": "社交"
        },
        {
            "境界": "沉默级",
            "描述": "能参与小范围社交（如熟人聚会），但全程以倾听为主，很少主动发言",
            "结束等级": "39",
            "起始等级": "30",
            "领域": "社交"
        },
        {
            "境界": "破冰级",
            "描述": "可主动开启简单话题（如天气、环境），但难以维持 3 句话以上的交流",
            "结束等级": "49",
            "起始等级": "40",
            "领域": "社交"
        },
        {
            "境界": "基础级",
            "描述": "能和陌生人完成 5-10 分钟日常对话（如购物砍价、问路），逻辑清晰",
            "结束等级": "59",
            "起始等级": "50",
            "领域": "社交"
        },
        {
            "境界": "适配级",
            "描述": "面对不同身份的人（如同事、长辈），能调整说话语气和内容",
            "结束等级": "69",
            "起始等级": "60",
            "领域": "社交"
        },
        {
            "境界": "维持级",
            "描述": "可通过分享日常（如兴趣、见闻），将单次交流延伸为短期联系",
            "结束等级": "79",
            "起始等级": "70",
            "领域": "社交"
        },
        {
            "境界": "拓展级",
            "描述": "能主动加入陌生社交圈（如兴趣群、线下活动），并认识 1-2 位新朋友",
            "结束等级": "89",
            "起始等级": "80",
            "领域": "社交"
        },
        {
            "境界": "共情级",
            "描述": "交流时能感知对方情绪（如对方失落时不泼冷水），给出基本安慰",
            "结束等级": "99",
            "起始等级": "90",
            "领域": "社交"
        },
        {
            "境界": "化解级",
            "描述": "遇到轻微社交尴尬（如冷场、口误），能主动找话题或自嘲化解",
            "结束等级": "109",
            "起始等级": "100",
            "领域": "社交"
        },
        {
            "境界": "深度级",
            "描述": "可与他人展开深度交流（如探讨观点、分享困惑），建立信任关系",
            "结束等级": "119",
            "起始等级": "110",
            "领域": "社交"
        },
        {
            "境界": "协调级",
            "描述": "在 3-5 人的小团队中，能协调不同意见（如组织聚会时平衡众人需求）",
            "结束等级": "129",
            "起始等级": "120",
            "领域": "社交"
        },
        {
            "境界": "主导级",
            "描述": "可主导 10 人以内的社交活动（如主持小型分享会），把控节奏和方向",
            "结束等级": "139",
            "起始等级": "130",
            "领域": "社交"
        },
        {
            "境界": "人脉级",
            "描述": "能有意识维护人脉（如节日问候、资源分享），形成稳定社交网络",
            "结束等级": "149",
            "起始等级": "140",
            "领域": "社交"
        },
        {
            "境界": "化解级",
            "描述": "面对复杂社交矛盾（如人际冲突），能中立调解，促成双方沟通",
            "结束等级": "159",
            "起始等级": "150",
            "领域": "社交"
        },
        {
            "境界": "影响级",
            "描述": "在社交中能输出观点，获得部分人认可（如带动他人参与公益）",
            "结束等级": "169",
            "起始等级": "160",
            "领域": "社交"
        },
        {
            "境界": "跨界级",
            "描述": "可轻松融入不同领域的社交圈（如从职场圈拓展到艺术圈），快速适应",
            "结束等级": "179",
            "起始等级": "170",
            "领域": "社交"
        },
        {
            "境界": "权威级",
            "描述": "在某一领域的社交中成为核心人物（如行业论坛核心参与者），有话语权",
            "结束等级": "189",
            "起始等级": "180",
            "领域": "社交"
        },
        {
            "境界": "资源级",
            "描述": "能整合多方社交资源（如对接供需、搭建合作），创造共同价值",
            "结束等级": "199",
            "起始等级": "190",
            "领域": "社交"
        },
        {
            "境界": "领袖级",
            "描述": "在大规模社交场景（如千人会议）中，能以个人魅力凝聚人群，引领方向",
            "结束等级": "999",
            "起始等级": "200",
            "领域": "社交"
        },
        {
            "境界": "天真",
            "描述": "头脑简单，容易被假象迷惑",
            "结束等级": "9",
            "起始等级": "1",
            "领域": "内修"
        },
        {
            "境界": "懵懂",
            "描述": "无自省意识，从不反思自身行为与想法",
            "结束等级": "19",
            "起始等级": "10",
            "领域": "内修"
        },
        {
            "境界": "偶思",
            "描述": "仅在犯错或受挫后，被动产生短暂反思",
            "结束等级": "29",
            "起始等级": "20",
            "领域": "内修"
        },
        {
            "境界": "浅思",
            "描述": "能主动回想日常小事，但仅停留在 “这件事我做了” 的表面",
            "结束等级": "39",
            "起始等级": "30",
            "领域": "内修"
        },
        {
            "境界": "归因",
            "描述": "开始思考行为背后的原因，能区分 “客观因素” 与 “自身问题”",
            "结束等级": "49",
            "起始等级": "40",
            "领域": "内修"
        },
        {
            "境界": "聚焦",
            "描述": "可针对性反思核心问题（如情绪、沟通），而非泛泛而谈",
            "结束等级": "59",
            "起始等级": "50",
            "领域": "内修"
        },
        {
            "境界": "规划",
            "描述": "反思后会简单记录改进方向，有初步 “想改变” 的念头",
            "结束等级": "69",
            "起始等级": "60",
            "领域": "内修"
        },
        {
            "境界": "尝试",
            "描述": "针对反思结论，偶尔尝试调整行为（如控制脾气），但易中断",
            "结束等级": "79",
            "起始等级": "70",
            "领域": "内修"
        },
        {
            "境界": "初律",
            "描述": "能坚持 1-2 周改进计划（如每日复盘），形成初步自律习惯",
            "结束等级": "89",
            "起始等级": "80",
            "领域": "内修"
        },
        {
            "境界": "巩固",
            "描述": "将短期习惯转化为日常（如固定时间自省），中断后能快速恢复",
            "结束等级": "99",
            "起始等级": "90",
            "领域": "内修"
        },
        {
            "境界": "复盘",
            "描述": "以自省结果为依据，制定明确自律目标（如每周 3 次深度复盘）",
            "结束等级": "109",
            "起始等级": "100",
            "领域": "内修"
        },
        {
            "境界": "抗扰",
            "描述": "面对干扰（如疲惫、诱惑），仍能大概率坚持自律计划",
            "结束等级": "119",
            "起始等级": "110",
            "领域": "内修"
        },
        {
            "境界": "灵活",
            "描述": "计划受阻时不焦虑，会调整方式而非放弃（如没时间复盘就缩短时长）",
            "结束等级": "129",
            "起始等级": "120",
            "领域": "内修"
        },
        {
            "境界": "整合",
            "描述": "将多个自律习惯串联（如自省→规划→执行→再自省），形成闭环",
            "结束等级": "139",
            "起始等级": "130",
            "领域": "内修"
        },
        {
            "境界": "接纳",
            "描述": "接受自律中的不完美，不因偶尔中断否定整体，减少内耗",
            "结束等级": "149",
            "起始等级": "140",
            "领域": "内修"
        },
        {
            "境界": "适配",
            "描述": "能根据自身状态调整自律强度（如生病时降低运动频率），不盲目坚持",
            "结束等级": "159",
            "起始等级": "150",
            "领域": "内修"
        },
        {
            "境界": "自洽",
            "描述": "自律不再靠 “意志力硬撑”，而是与自身需求、节奏匹配，内心无抵触",
            "结束等级": "169",
            "起始等级": "160",
            "领域": "内修"
        },
        {
            "境界": "内化",
            "描述": "自省成为本能反应，遇到问题先复盘；自律成为生活常态，无需刻意提醒",
            "结束等级": "179",
            "起始等级": "170",
            "领域": "内修"
        },
        {
            "境界": "赋能",
            "描述": "从自省中获得成长动力，从自律中感受掌控感，两者相互促进",
            "结束等级": "189",
            "起始等级": "180",
            "领域": "内修"
        },
        {
            "境界": "平衡",
            "描述": "在 “要求自己” 与 “善待自己” 间找到平衡，不苛责也不放纵",
            "结束等级": "199",
            "起始等级": "190",
            "领域": "内修"
        },
        {
            "境界": "自在",
            "描述": "自省不纠结过去，自律不焦虑未来，内在状态稳定从容，实现深度自洽",
            "结束等级": "999",
            "起始等级": "200",
            "领域": "内修"
        }
    ],
    "quickAddTaskHint": "类别: 主辅支特abct | 领域: 学工体生社自swelom | 优先级: hijk | 周期: 无日周月年xrzyn",
    "sellRates": {
        "星钻": {
            "元宝": 1,
            "金币": 10
        },
        "水晶": {
            "元宝": 1,
            "金币": 10
        },
        "源石": {
            "元宝": 1,
            "金币": 10
        },
        "灵石": {
            "元宝": 1,
            "金币": 10
        },
        "骨贝": {
            "元宝": 1,
            "金币": 10
        },
        "魂玉": {
            "元宝": 1,
            "金币": 10
        }
    },

    "taskFieldMappings": {
        "categories": {
            "主线任务": {
                "abbreviation": "主",
                "code": "a",
                "color": "#ff5252",
                "weight": 8
            },
            "支线任务": {
                "abbreviation": "支",
                "code": "c",
                "color": "#feee8b",
                "weight": 2
            },
            "特殊任务": {
                "abbreviation": "特",
                "code": "t",
                "color": "#04fb08",
                "weight": 1
            },
            "辅线任务": {
                "abbreviation": "辅",
                "code": "b",
                "color": "#f5873d",
                "weight": 4
            }
        },
        "cycleTypes": {
            "周循环": {
                "abbreviation": "周",
                "code": "z",
                "color": "#f5873d",
                "weight": 0
            },
            "年循环": {
                "abbreviation": "年",
                "code": "n",
                "color": "#04fb08",
                "weight": 0
            },
            "无循环": {
                "abbreviation": "无",
                "code": "x",
                "color": "#56d7c2",
                "weight": 0
            },
            "日循环": {
                "abbreviation": "日",
                "code": "r",
                "color": "#ff5252",
                "weight": 0
            },
            "月循环": {
                "abbreviation": "月",
                "code": "y",
                "color": "#feee8b",
                "weight": 0
            }
        },
        "domains": {
            "学习": {
                "abbreviation": "学",
                "code": "s",
                "color": "#ae0ce9",
                "weight": 3
            },
            "工作": {
                "abbreviation": "工",
                "code": "w",
                "color": "#ff5252",
                "weight": 4
            },
            "生活": {
                "abbreviation": "生",
                "code": "l",
                "color": "#feee8b",
                "weight": 1
            },
            "社交": {
                "abbreviation": "社",
                "code": "o",
                "color": "#04fb08",
                "weight": 1
            },
            "内修": {
                "abbreviation": "自",
                "code": "m",
                "color": "#0081fa",
                "weight": 1
            },
            "运动": {
                "abbreviation": "运",
                "code": "e",
                "color": "#f5873d",
                "weight": 2
            }
        },
        "priorities": {
            "不重要不紧急": {
                "abbreviation": "轻缓",
                "code": "k",
                "color": "#04fb08",
                "weight": 1
            },
            "不重要但紧急": {
                "abbreviation": "轻急",
                "code": "j",
                "color": "#feee8b",
                "weight": 2
            },
            "重要不紧急": {
                "abbreviation": "重缓",
                "code": "i",
                "color": "#f5873d",
                "weight": 3
            },
            "重要且紧急": {
                "abbreviation": "重急",
                "code": "h",
                "color": "#ff5252",
                "weight": 4
            }
        },
        "statuses": {
            "已完成": {
                "abbreviation": "已完",
                "color": "#04fb08",
                "weight": 0
            },
            "未完成": {
                "abbreviation": "未完",
                "color": "#ff5252",
                "weight": 0
            },
            "进行中": {
                "abbreviation": "进行",
                "color": "#f5873d",
                "weight": 0
            },
            "重复中": {
                "abbreviation": "重复",
                "color": "#feee8b",
                "weight": 0
            }
        }
    },

    "toolbarSettings": {
        "buttons": [
            {
                "id": "list",
                "type": "view",
                "visible": True
            },
            {
                "id": "board",
                "type": "view",
                "visible": True
            },
            {
                "id": "calendar",
                "type": "view",
                "visible": True
            },
            {
                "id": "card",
                "type": "view",
                "visible": True
            },
            {
                "id": "scale",
                "type": "control",
                "visible": True
            },
            {
                "id": "refresh",
                "type": "control",
                "visible": True
            },
            {
                "id": "hide",
                "type": "control",
                "visible": False
            },
            {
                "id": "logs",
                "type": "control",
                "visible": False
            },
            {
                "id": "quick",
                "type": "control",
                "visible": False
            },
            {
                "id": "position",
                "type": "control",
                "visible": True
            }
        ]
    },
    "tooltipTrigger": "shift"

}


def get_user_dir(username):
    """获取用户数据目录"""
    return os.path.join(USERS_DIR, username)


# 全局配置管理器类
class GlobalConfigManager:
    _instance = None
    _current_username = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(GlobalConfigManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self._initialized = True
        # self._current_user_settings = {}
        # self._current_user_data = {}
        # self.reset_to_global()

    def set_current_user(self, username):
        """设置当前用户"""
        self._current_username = username

        if username:
            # 用户特定配置
            user_dir = os.path.join(USERS_DIR, username)
            self.DATA_FILE = os.path.join(user_dir, "master_data.json")
            self.LOGS_FILE = os.path.join(user_dir, "logs.json")
            self.SETTINGS_FILE = os.path.join(user_dir, "settings.json")

            # 用户文件夹路径
            self.MARKDOWN_FILES_DIR = os.path.join(user_dir, "files")
            self.NOTES_DIR = os.path.join(self.MARKDOWN_FILES_DIR, "notes")
            self.IMAGES_DIR = os.path.join(self.MARKDOWN_FILES_DIR, "images")
            self.JOURNALS_DIR = os.path.join(self.MARKDOWN_FILES_DIR, "journals")

            self.MARKDOWN_TREE_FILE = os.path.join(self.NOTES_DIR, "file_tree.json")
            # print("用户数据初始化完成:", user_dir)
        # else:
            # 全局配置（默认配置）
            # self.reset_to_global()

        # 确保目录存在
        self.ensure_directories_exist()



    def reset_to_global(self):
        """重置为全局配置"""
        self._current_username = None
        self.DATA_FILE = "./master_data.json"
        self.LOGS_FILE = "logs.json"
        self.SETTINGS_FILE = "settings.json"

        # 全局文件夹路径
        self.MARKDOWN_FILES_DIR = "./files"
        self.NOTES_DIR = os.path.join(self.MARKDOWN_FILES_DIR, "notes")
        self.IMAGES_DIR = os.path.join(self.MARKDOWN_FILES_DIR, "images")
        self.JOURNALS_DIR = os.path.join(self.MARKDOWN_FILES_DIR, "journals")
        self.MARKDOWN_TREE_FILE = os.path.join(self.NOTES_DIR, "file_tree.json")

    def ensure_directories_exist(self):
        """确保所有必需的目录都存在"""
        try:
            dirs_to_create = [
                self.MARKDOWN_FILES_DIR,
                self.NOTES_DIR,
                self.IMAGES_DIR,
                self.JOURNALS_DIR
            ]

            for directory in dirs_to_create:
                os.makedirs(directory, exist_ok=True)
        except Exception as e:
            print(f"创建目录时出错: {e}")

# 创建全局配置管理器实例
config_manager = GlobalConfigManager()


# 用户系统初始化函数
def initialize_user_system():
    """初始化用户系统"""
    os.makedirs(USERS_DIR, exist_ok=True)

    # 如果用户数据库不存在，创建空文件
    if not os.path.exists(USERS_DB_FILE):
        with open(USERS_DB_FILE, 'w') as f:
            json.dump({}, f)

# 在应用启动时调用初始化
initialize_user_system()

# 用户数据库操作函数
def get_user_db():
    """获取用户数据库"""
    if os.path.exists(USERS_DB_FILE):
        with open(USERS_DB_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def save_user_db(db):
    """保存用户数据库"""
    with open(USERS_DB_FILE, 'w', encoding='utf-8') as f:
        json.dump(db, f, ensure_ascii=False, indent=2)




def init_user_data(username):
    """初始化用户数据目录和默认文件"""
    user_dir = os.path.join(USERS_DIR, username)
    os.makedirs(user_dir, exist_ok=True)

    # 复制或创建默认配置文件
    for file in DEFAULT_DATA_FILES:
        user_file = os.path.join(user_dir, file)
        if not os.path.exists(user_file) and os.path.exists(file):
            import shutil
            shutil.copy(file, user_file)
        elif not os.path.exists(user_file):
            # 创建默认文件
            with open(user_file, 'w', encoding='utf-8') as f:
                if file == 'settings.json':
                    # 使用 default_settings 创建默认设置文件
                    json.dump(default_settings, f, ensure_ascii=False, indent=2)
                elif file == 'master_data.json':
                    # 使用 get_default_data 创建默认主数据文件
                    json.dump(get_default_data(), f, ensure_ascii=False, indent=2)
                # elif file.endswith('.json'):
                #     # 其他 JSON 文件创建空对象或数组
                #     json.dump({} if file != 'logs.json' else {}, f, ensure_ascii=False, indent=2)


    # 创建用户文件夹结构，与全局结构保持一致
    os.makedirs(os.path.join(user_dir, 'files'), exist_ok=True)
    os.makedirs(os.path.join(user_dir, 'files', 'notes'), exist_ok=True)
    os.makedirs(os.path.join(user_dir, 'files', 'images'), exist_ok=True)
    os.makedirs(os.path.join(user_dir, 'files', 'journals'), exist_ok=True)

    # 创建欢迎笔记
    # create_welcome_note(os.path.join(user_dir, 'files', 'notes', 'welcome'))

def create_welcome_note(path):
    """创建欢迎笔记"""
    WELCOME_NOTE = """
# 欢迎使用GLifeist

GLifeist是一个基于Python+Javascript的开源游戏化任务管理工具，包含以下组件：

## 任务
## 背包
## 商店
## 道具
## 工坊
## 笔记
"""
    with open(path, 'w', encoding='utf-8') as f:
        f.write(WELCOME_NOTE)






# JWT令牌操作函数
def generate_tokens_old(username):
    """生成访问令牌和刷新令牌"""
    access_payload = {
        'username': username,
        'exp': datetime.utcnow() + JWT_ACCESS_EXPIRATION_DELTA
    }

    refresh_payload = {
        'username': username,
        'exp': datetime.utcnow() + JWT_REFRESH_EXPIRATION_DELTA
    }

    access_token = jwt.encode(access_payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
    refresh_token = jwt.encode(refresh_payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

    return access_token, refresh_token

def generate_tokens(username, long_term=False):
    """生成访问令牌和刷新令牌，支持长期登录选项"""
    if long_term:
        # 长期登录，使用14天过期时间
        access_payload = {
            'username': username,
            'exp': datetime.utcnow() + JWT_LONG_TERM_EXPIRATION_DELTA,
            'long_term': True  # 标记为长期登录
        }
        refresh_payload = {
            'username': username,
            'exp': datetime.utcnow() + JWT_LONG_TERM_EXPIRATION_DELTA
        }
    else:
        # 普通登录，使用默认过期时间
        access_payload = {
            'username': username,
            'exp': datetime.utcnow() + JWT_ACCESS_EXPIRATION_DELTA
        }
        refresh_payload = {
            'username': username,
            'exp': datetime.utcnow() + JWT_REFRESH_EXPIRATION_DELTA
        }

    access_token = jwt.encode(access_payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
    refresh_token = jwt.encode(refresh_payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

    return access_token, refresh_token

def verify_token(token):
    """验证JWT令牌"""
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        return payload['username']
    except jwt.ExpiredSignatureError:
        return None
    except jwt.InvalidTokenError:
        return None


# 认证装饰器
def token_required(optional=False):
    """JWT令牌验证装饰器，支持可选认证"""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get('Authorization')
            username = None

            if token:
                # 移除Bearer前缀
                if token.startswith('Bearer '):
                    token = token[7:]
                username = verify_token(token)

            if username is not None:
                # 将用户名添加到请求上下文
                request.current_user = username

                # 根据用户身份设置全局配置
                config_manager.set_current_user(username)
                print(f"当前用户: {username} - {config_manager.DATA_FILE}/{config_manager.IMAGES_DIR}/{config_manager.JOURNALS_DIR}")

            # 如果认证是可选的，或者用户已认证，则继续执行
            if optional or username:
                return f(*args, **kwargs)
            else:
                return jsonify({'error': 'Authentication required'}), 401

        return decorated_function

    return decorator

# 修改数据访问函数以支持用户隔离
# def get_data_file_path(username=None):
#     """获取数据文件路径"""
#     if username:
#         return os.path.join(get_user_dir(username), 'master_data.json')
#     return DATA_FILE
#
# def get_settings_file_path(username=None):
#     """获取设置文件路径"""
#     if username:
#         return os.path.join(get_user_dir(username), 'settings.json')
#     return SETTINGS_FILE

# def get_logs_file_path(username=None):
#     """获取日志文件路径"""
#     if username:
#         return os.path.join(get_user_dir(username), 'logs.json')
#     return LOGS_FILE


# 修改load_data函数以支持用户隔离
def load_data(allow_default=True):
    """从文件加载数据"""
    global _executing_auto_tasks
    try:
        data = None

        if os.path.exists(config_manager.DATA_FILE):
            with open(config_manager.DATA_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # 确保所有必需的字段都存在
            stats = data.get("stats", generate_default_stats())
            properties = data.get("properties", generate_default_properties())
            credits = data.get("credits", generate_default_credits())
            items = data.get("items", generate_default_items())
            backpack = data.get("backpack", {item: 0 for item in items})
            # conversion_rates = data.get("conversion_rates", generate_default_conversion_rates())
            tasks = data.get("tasks", generate_default_tasks())
            lootbox_miss_counts = data.get("lootbox_miss_counts", {})

            # 处理旧数据兼容性
            for task in tasks:
                if "task_type" not in task:
                    task["task_type"] = "无循环"
                if "completed_count" not in task:
                    task["completed_count"] = 0
                if "max_completions" not in task:
                    task["max_completions"] = 0

            result = {
                "stats": stats,
                "properties": properties,
                "credits": credits,
                "items": items,
                "backpack": backpack,
                # "conversion_rates": conversion_rates,
                "tasks": tasks,
                "lootbox_miss_counts":lootbox_miss_counts
            }

            # 在加载数据后执行自动任务检查（仅在非递归调用时执行）
            if not _executing_auto_tasks:
                _executing_auto_tasks = True
                try:
                    execute_daily_auto_tasks()
                finally:
                    _executing_auto_tasks = False

            return result
        else:
            # 使用动态生成的默认数据
            if allow_default:
                print("数据文件不存在，已启用默认数据")
                result = get_default_data()

                # 保存默认数据到文件
                if not save_data(result):
                    print(f"保存默认数据失败: {config_manager.DATA_FILE}")

                # 对于新数据也执行自动任务检查
                if not _executing_auto_tasks:
                    _executing_auto_tasks = True
                    try:
                        execute_daily_auto_tasks()
                    finally:
                        _executing_auto_tasks = False
                return result
            else:
                print(f"数据文件不存在: {config_manager.DATA_FILE}")
                raise FileNotFoundError

    except Exception as e:
        # 使用动态生成的默认数据
        if allow_default:
            print(f"加载数据失败: {str(e)}\n 已启用默认数据")
            result = get_default_data()

            # 保存默认数据到文件
            if not save_data(result):
                print(f"保存默认数据失败: {config_manager.DATA_FILE}")

            # 对于出错情况也执行自动任务检查
            if not _executing_auto_tasks:
                _executing_auto_tasks = True
                try:
                    execute_daily_auto_tasks()
                finally:
                    _executing_auto_tasks = False
            return result
        else:
            print(f"加载数据失败: {str(e)}")
            raise e

def load_settings():
    """从文件加载设置"""

    # 如果已有缓存且是全局配置，直接返回
    # if config_manager._current_user_settings:
    #     print('load_settings - 1. returning _settings_cache')
    #     return config_manager._current_user_settings
    try:
        if os.path.exists(config_manager.SETTINGS_FILE):
            with open(config_manager.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                settings = json.load(f)
                # config_manager._current_user_settings = settings
                # print('load_settings - 2. returning settings')
                return settings
        else:
            # 如果设置文件不存在，创建默认设置文件
            save_settings(default_settings)
            # config_manager._current_user_settings = default_settings
            # print('load_settings - 3. returning default settings')
            return default_settings
    except Exception as e:
        print(f"加载设置失败: {str(e)}")
        # config_manager._current_user_setting = default_settings
        # print('load_settings - 4. returning except default settings')
        return default_settings

def save_data(data):
    """保存数据到文件"""
    try:
        with open(config_manager.DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"保存数据失败: {str(e)}")
        return False

def save_settings(settings):
    """保存设置到文件"""
    try:
        with open(config_manager.SETTINGS_FILE, 'w', encoding='utf-8') as f:
            json.dump(settings, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"保存设置失败: {str(e)}")
        return False




# 更新文件管理相关函数以使用全局配置
def load_file_tree():
    """加载文件树结构"""
    try:
        if os.path.exists(config_manager.MARKDOWN_TREE_FILE):
            with open(config_manager.MARKDOWN_TREE_FILE, 'r', encoding='utf-8') as f:
                content = f.read().strip()
                if content:  # 检查文件是否为空
                    tree_data = json.loads(content)
                    # 检查并添加欢迎文件节点（如果不存在）
                    # ensure_welcome_file_node(tree_data)
                    return tree_data
                else:
                    # 文件存在但为空，创建默认结构
                    default_tree = create_default_file_tree()
                    # 确保创建欢迎文件节点
                    # ensure_welcome_file_node(default_tree)
                    save_file_tree(default_tree)
                    return default_tree
        else:
            # 文件不存在，创建默认文件树
            default_tree = create_default_file_tree()
            # 确保创建欢迎文件节点
            ensure_welcome_file_node(default_tree)
            save_file_tree(default_tree)
            return default_tree
    except json.JSONDecodeError as e:
        print(f"文件树JSON格式错误: {str(e)}")
        # 创建新的默认文件树
        default_tree = create_default_file_tree()
        # 确保创建欢迎文件节点
        # ensure_welcome_file_node(default_tree)
        save_file_tree(default_tree)
        return default_tree
    except Exception as e:
        print(f"加载文件树失败: {str(e)}")
        # 返回默认文件树结构
        default_tree = create_default_file_tree()
        # 确保创建欢迎文件节点
        # ensure_welcome_file_node(default_tree)
        return default_tree

def create_default_file_tree():
    """创建默认文件树结构"""
    return [
        {
            "id": "root",
            "name": "笔记簿",
            "type": "folder",
            "children": [],
            "createdAt": datetime.now().isoformat(),
            "updatedAt": datetime.now().isoformat()
        }
    ]

def ensure_welcome_file_node(tree_data):
    """确保欢迎文件节点存在于文件树中"""
    try:
        # 查找根节点
        if not tree_data or len(tree_data) == 0:
            return

        root_node = tree_data[0]
        if root_node.get('id') != 'root' or 'children' not in root_node:
            return

        # 检查是否已存在 welcome 文件节点
        welcome_exists = any(
            child.get('id') == 'welcome'
            for child in root_node.get('children', [])
        )

        # 如果不存在 welcome 文件节点，则添加
        if not welcome_exists:
            welcome_node = {
                'id': 'welcome',
                'name': '欢迎使用.md',
                'type': 'file',
                'createdAt': datetime.now().isoformat(),
                'updatedAt': datetime.now().isoformat()
            }
            root_node['children'].append(welcome_node)

        # 确保 welcome 文件实际存在
        create_welcome_file_if_not_exists()

    except Exception as e:
        print(f"确保欢迎文件节点存在时出错: {str(e)}")

def create_welcome_file_if_not_exists():
    """如果 welcome 文件不存在则创建它"""
    try:
        welcome_file_path = os.path.join(config_manager.NOTES_DIR, 'welcome.md')

        # 如果文件已存在，直接返回
        if os.path.exists(welcome_file_path):
            return

        # 确保 notes 目录存在
        os.makedirs(config_manager.NOTES_DIR, exist_ok=True)

        # 创建欢迎文件内容
        welcome_content = """# 欢迎使用笔记簿

这是一个功能强大的 Markdown 编辑器，支持以下功能：

- 实时预览
- 任务列表
- 代码高亮
- 文件管理

开始创建您的第一个文档吧！"""

        # 写入文件
        with open(welcome_file_path, 'w', encoding='utf-8') as f:
            f.write(welcome_content)

        print(f"已创建欢迎文件: {welcome_file_path}")

    except Exception as e:
        print(f"创建欢迎文件时出错: {str(e)}")

def save_file_tree(tree):
    """保存文件树结构"""
    try:
        print("正在保存文件树结构...")
        with open(config_manager.MARKDOWN_TREE_FILE, 'w', encoding='utf-8') as f:
            json.dump(tree, f, ensure_ascii=False, indent=2)
        print("文件树保存成功")
        return True
    except Exception as e:
        print(f"保存文件树失败: {str(e)}")
        return False

def get_file_path(file_id):
    """获取文件在磁盘上的路径"""
    return os.path.join(config_manager.NOTES_DIR, f"{file_id}.md")

def get_journal_path(file_id):
    """获取JNL文件在磁盘上的路径"""
    return os.path.join(config_manager.JOURNALS_DIR, f"{file_id}.md")






def get_all_image_files():
    """获取所有图片文件"""
    try:
        image_files = []
        if os.path.exists(config_manager.IMAGES_DIR):
            for filename in os.listdir(config_manager.IMAGES_DIR):
                if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                    file_path = os.path.join(config_manager.IMAGES_DIR, filename)
                    image_files.append({
                        "name": filename,
                        "size": os.path.getsize(file_path),
                        "modified": datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat()
                    })
        return image_files
    except Exception as e:
        print(f"获取图片文件列表失败: {str(e)}")
        return []













#
# # 用户认证路由
# @app.route('/api/auth/register', methods=['POST'])
# def register():
#     """用户注册"""
#     data = request.get_json()
#     username = data.get('username')
#     password = data.get('password')
#
#     if not username or not password:
#         return jsonify({'error': 'Username and password are required'}), 400
#
#     if len(username) < 3 or len(username) > 20:
#         return jsonify({'error': 'Username must be between 3 and 20 characters'}), 400
#
#     if len(password) < 6:
#         return jsonify({'error': 'Password must be at least 6 characters'}), 400
#
#     users_db = get_user_db()
#     if username in users_db:
#         return jsonify({'error': 'User already exists'}), 400
#
#     # 密码哈希
#     hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
#
#     users_db[username] = {
#         'password': hashed_password,
#         'id': str(uuid.uuid4()),
#         'created_at': datetime.now().isoformat(),
#         'permissions': ['user']  # 默认权限
#     }
#     save_user_db(users_db)
#
#     # 初始化用户数据
#     init_user_data(username)
#
#     return jsonify({'message': 'User registered successfully'})
#
#
# @app.route('/api/auth/login', methods=['POST'])
# def login():
#     """用户登录"""
#     data = request.get_json()
#     username = data.get('username')
#     password = data.get('password')
#
#     if not username or not password:
#         return jsonify({'error': 'Username and password are required'}), 400
#
#     users_db = get_user_db()
#     if username not in users_db:
#         return jsonify({'error': 'Invalid credentials'}), 401
#
#     stored_hash = users_db[username]['password']
#     if not bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8')):
#         return jsonify({'error': 'Invalid credentials'}), 401
#
#     # 生成令牌
#     access_token, refresh_token = generate_tokens(username)
#
#     return jsonify({
#         'message': 'Login successful',
#         'username': username,
#         'access_token': access_token,
#         'refresh_token': refresh_token
#     })
#
#
# @app.route('/api/auth/refresh', methods=['POST'])
# def refresh():
#     """刷新访问令牌"""
#     refresh_token = request.json.get('refresh_token')
#     if not refresh_token:
#         return jsonify({'error': 'Refresh token is missing'}), 400
#
#     username = verify_token(refresh_token)
#     if not username:
#         return jsonify({'error': 'Invalid or expired refresh token'}), 401
#
#     # 生成新的令牌对
#     new_access_token, new_refresh_token = generate_tokens(username)
#
#     return jsonify({
#         'access_token': new_access_token,
#         'refresh_token': new_refresh_token
#     })
#
#
# @app.route('/api/auth/logout', methods=['POST'])
# @token_required()
# def logout():
#     """用户登出"""
#     # 在实际应用中，可能需要将令牌加入黑名单
#     return jsonify({'message': 'Logout successful'})
#
#
# @app.route('/api/user/profile', methods=['GET'])
# @token_required()
# def get_profile():
#     """获取用户资料"""
#     username = request.current_user
#     users_db = get_user_db()
#     user_info = users_db.get(username, {})
#
#     # 移除敏感信息
#     user_info.pop('password', None)
#
#     return jsonify({
#         'username': username,
#         'profile': user_info
#     })
#
#
# # 权限检查装饰器
# def require_permission(permission):
#     """权限检查装饰器"""
#
#     def decorator(f):
#         @wraps(f)
#         def decorated_function(*args, **kwargs):
#             username = request.current_user
#             if not username:
#                 return jsonify({'error': 'Authentication required'}), 401
#
#             users_db = get_user_db()
#             user_permissions = users_db.get(username, {}).get('permissions', [])
#
#             if permission not in user_permissions and 'admin' not in user_permissions:
#                 return jsonify({'error': 'Insufficient permissions'}), 403
#
#             return f(*args, **kwargs)
#
#         return decorated_function
#
#     return decorator
#
#
# # 管理员路由
# @app.route('/api/admin/users', methods=['GET'])
# @token_required()
# @require_permission('admin')
# def list_users():
#     """管理员获取用户列表"""
#     users_db = get_user_db()
#     # 移除密码等敏感信息
#     users_list = []
#     for username, user_info in users_db.items():
#         user_info_clean = user_info.copy()
#         user_info_clean.pop('password', None)
#         users_list.append({
#             'username': username,
#             'info': user_info_clean
#         })
#
#     return jsonify(users_list)
#
#
# # 用户数据访问函数
# def get_user_data_path(username, data_type):
#     """获取用户数据文件路径"""
#     if not username:
#         # 未认证用户使用全局数据
#         return f"{data_type}.json"
#     return os.path.join(get_user_dir(username), f"{data_type}.json")
#
#
# # 修改现有的数据访问API以支持用户隔离
# @app.route('/api/settings', methods=['GET', 'POST'])
# @token_required(optional=True)  # 可选认证，向后兼容
# def handle_settings():
#     """处理用户设置"""
#     username = request.current_user
#     settings_path = get_user_data_path(username, 'settings')
#
#     if request.method == 'GET':
#         if os.path.exists(settings_path):
#             with open(settings_path, 'r', encoding='utf-8') as f:
#                 return jsonify(json.load(f))
#         else:
#             return jsonify({})
#
#     elif request.method == 'POST':
#         with open(settings_path, 'w', encoding='utf-8') as f:
#             json.dump(request.get_json(), f, ensure_ascii=False, indent=2)
#         return jsonify({'message': 'Settings saved'})
#
#
# @app.route('/api/logs', methods=['GET', 'POST'])
# @token_required(optional=True)
# def handle_logs():
#     """处理用户日志"""
#     username = request.current_user
#     logs_path = get_user_data_path(username, 'logs')
#
#     if request.method == 'GET':
#         if os.path.exists(logs_path):
#             with open(logs_path, 'r', encoding='utf-8') as f:
#                 return jsonify(json.load(f))
#         else:
#             return jsonify([])
#
#     elif request.method == 'POST':
#         with open(logs_path, 'w', encoding='utf-8') as f:
#             json.dump(request.get_json(), f, ensure_ascii=False, indent=2)
#         return jsonify({'message': 'Logs saved'})
#
#
# @app.route('/api/master-data', methods=['GET', 'POST'])
# @token_required(optional=True)
# def handle_master_data():
#     """处理用户主数据"""
#     username = request.current_user
#     master_data_path = get_user_data_path(username, 'master_data')
#
#     if request.method == 'GET':
#         if os.path.exists(master_data_path):
#             with open(master_data_path, 'r', encoding='utf-8') as f:
#                 return jsonify(json.load(f))
#         else:
#             return jsonify({})
#
#     elif request.method == 'POST':
#         with open(master_data_path, 'w', encoding='utf-8') as f:
#             json.dump(request.get_json(), f, ensure_ascii=False, indent=2)
#         return jsonify({'message': 'Master data saved'})
#
# # 文件管理路由 - 保持向后兼容
# @app.route('/api/tree', methods=['GET'])
# @token_required(optional=True)
# def get_file_tree():
#     """获取文件树"""
#     username = request.current_user
#     if username:
#         # 认证用户返回其个人文件树
#         user_files_dir = os.path.join(get_user_dir(username), 'files')
#         # 这里应该返回用户特定的文件树结构
#         return get_user_file_tree(user_files_dir)
#     else:
#         # 未认证用户返回全局文件树
#         return get_global_file_tree()
#
# def get_global_file_tree():
#     """获取全局文件树（向后兼容）"""
#     # 保持原有逻辑
#     pass
#
# def get_user_file_tree(user_files_dir):
#     """获取用户文件树"""
#     # 实现用户文件树逻辑
#     pass
#
# # 保持原有API接口向后兼容
# @app.route('/api/file/<file_id>', methods=['GET', 'POST', 'DELETE'])
# @token_required(optional=True)
# def handle_file(file_id):
#     """处理文件操作"""
#     username = request.current_user
#     # 根据认证状态决定文件访问路径
#     if username:
#         # 用户文件操作
#         user_file_path = os.path.join(get_user_dir(username), 'files', file_id)
#         # 处理用户文件
#     else:
#         # 全局文件操作（向后兼容）
#         # 保持原有逻辑
#         pass































# # 文件管理路由
# @app.route('/api/files/list', methods=['GET'])
# @token_required
# def list_files():
#     """列出用户文件"""
#     username = request.current_user
#     user_files_dir = os.path.join(get_user_dir(username), 'files')
#
#     if not os.path.exists(user_files_dir):
#         return jsonify([])
#
#     files = []
#     for root, dirs, filenames in os.walk(user_files_dir):
#         for filename in filenames:
#             filepath = os.path.join(root, filename)
#             rel_path = os.path.relpath(filepath, user_files_dir)
#             files.append({
#                 'name': filename,
#                 'path': rel_path,
#                 'size': os.path.getsize(filepath),
#                 'modified': os.path.getmtime(filepath)
#             })
#
#     return jsonify(files)
#
#
# @app.route('/api/files/save', methods=['POST'])
# @token_required
# def save_file():
#     """保存用户文件"""
#     username = request.current_user
#     data = request.get_json()
#     filename = data.get('filename')
#     content = data.get('content')
#
#     if not filename or content is None:
#         return jsonify({'error': 'Filename and content are required'}), 400
#
#     user_file_path = os.path.join(get_user_dir(username), 'files', filename)
#
#     # 确保目录存在
#     os.makedirs(os.path.dirname(user_file_path), exist_ok=True)
#
#     with open(user_file_path, 'w', encoding='utf-8') as f:
#         f.write(content)
#
#     return jsonify({'message': 'File saved successfully'})
#
#
# @app.route('/api/files/load', methods=['POST'])
# @token_required
# def load_file():
#     """加载用户文件"""
#     username = request.current_user
#     data = request.get_json()
#     filename = data.get('filename')
#
#     if not filename:
#         return jsonify({'error': 'Filename is required'}), 400
#
#     user_file_path = os.path.join(get_user_dir(username), 'files', filename)
#
#     if not os.path.exists(user_file_path):
#         return jsonify({'error': 'File not found'}), 404
#
#     with open(user_file_path, 'r', encoding='utf-8') as f:
#         content = f.read()
#
#     return jsonify({'content': content})
#
#
# @app.route('/api/files/delete', methods=['POST'])
# @token_required
# def delete_file():
#     """删除用户文件"""
#     username = request.current_user
#     data = request.get_json()
#     filename = data.get('filename')
#
#     if not filename:
#         return jsonify({'error': 'Filename is required'}), 400
#
#     user_file_path = os.path.join(get_user_dir(username), 'files', filename)
#
#     if not os.path.exists(user_file_path):
#         return jsonify({'error': 'File not found'}), 404
#
#     os.remove(user_file_path)
#     return jsonify({'message': 'File deleted successfully'})
#
#
# # 权限检查装饰器
# def require_permission(permission):
#     """权限检查装饰器"""
#
#     def decorator(f):
#         @wraps(f)
#         def decorated_function(*args, **kwargs):
#             username = request.current_user
#             users_db = get_user_db()
#             user_permissions = users_db.get(username, {}).get('permissions', [])
#
#             if permission not in user_permissions and 'admin' not in user_permissions:
#                 return jsonify({'error': 'Insufficient permissions'}), 403
#
#             return f(*args, **kwargs)
#
#         return decorated_function
#
#     return decorator
#
#
# # 管理员路由
# @app.route('/api/admin/users', methods=['GET'])
# @token_required
# @require_permission('admin')
# def list_users():
#     """管理员获取用户列表"""
#     users_db = get_user_db()
#     # 移除密码等敏感信息
#     users_list = []
#     for username, user_info in users_db.items():
#         user_info_clean = user_info.copy()
#         user_info_clean.pop('password', None)
#         users_list.append({
#             'username': username,
#             'info': user_info_clean
#         })
#
#     return jsonify(users_list)
#
#
#
#
# # 速率限制装饰器
# from collections import defaultdict
# import time
#
# # 简单的速率限制实现
# request_counts = defaultdict(list)
#
#
# def rate_limit(max_requests=10, window=60):
#     """速率限制装饰器"""
#
#     def decorator(f):
#         @wraps(f)
#         def decorated_function(*args, **kwargs):
#             client_ip = request.remote_addr
#             now = time.time()
#
#             # 清理过期请求记录
#             request_counts[client_ip] = [
#                 timestamp for timestamp in request_counts[client_ip]
#                 if now - timestamp < window
#             ]
#
#             # 检查是否超过限制
#             if len(request_counts[client_ip]) >= max_requests:
#                 return jsonify({'error': 'Rate limit exceeded'}), 429
#
#             # 记录当前请求
#             request_counts[client_ip].append(now)
#
#             return f(*args, **kwargs)
#
#         return decorated_function
#
#     return decorator
#
#
# # 应用安全中间件
# @app.before_request
# def security_middleware():
#     """安全中间件"""
#     # 防止某些敏感路径被直接访问
#     sensitive_paths = ['/users.json', '/users/', '/app.py']
#     for path in sensitive_paths:
#         if request.path.startswith(path):
#             return jsonify({'error': 'Forbidden'}), 403



















# 数据文件路径







def generate_default_stats():
    """根据设置动态生成默认角色数据"""
    stats = ["level", "exp", "name", "avatar"]
    return {stats[0]:1, stats[1]:0, stats[2]:"冒险者", stats[3]:"🧙‍♂"}

def generate_default_credits():
    """根据设置动态生成默认积分数据"""
    credit_types =  ["水晶", "星钻", "魂玉", "骨贝", "源石", "灵石", "金币", "元宝"]
    return {credit_type: 0 for credit_type in credit_types}

def generate_default_properties():
    """根据设置动态生成默认属性数据"""
    property_categories =  ['智力','力量', '体质', '活力', '敏捷', '灵力']
    return {property_category : 0 for property_category in property_categories}

def generate_default_tasks():
    """根据设置动态生成默认任务数据"""
    # 添加默认任务
    default_tasks = [{
        "id": 1,
        "name": "初始任务",
        "description": "完成此初始任务可领取奖励",
        "task_type": "无循环",
        "max_completions": 1,
        "completed_count": 0,
        "category": "主线任务",
        "domain": "学习",
        "priority": "重要且紧急",
        "credits_reward": {credit_type: 10 for credit_type in ["水晶", "星钻", "魂玉", "骨贝", "源石", "灵石", "金币", "元宝"]},
        "items_reward": {},
        "exp_reward": 10,
        "status": "未完成",
        "start_time": datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
        "complete_time": None,
        "archived": False,
        "total_completion_count": 0,
    }]
    return default_tasks

def generate_default_items():
    """根据设置动态生成默认道具数据"""

    credit_types =  ["水晶", "星钻", "魂玉", "骨贝", "源石", "灵石", "金币", "元宝"]
    item_categories = ["经验类", "属性类", "消耗类", "装备类", "材料类", "任务类", "宝箱类","实物类","未分类"]

    # 创建默认道具，使其与实际使用的积分类型匹配
    items = {
        "经验书": {"id": 8888, "price": {credit_types[0]: 10.0}, "description": "增加经验值", "category": item_categories[0],
                   "icon": "📗"},
        "力量丸": {"id": 11302, "price": {credit_types[1]: 8.0}, "description": "增加力量", "category": item_categories[1],
                   "icon": "💊"},
        "生命药水": {"id": 11303, "price": {credit_types[2]: 6.0}, "description": "恢复生命值", "category": item_categories[2],
                     "icon": "💉"},
        "魔法药水": {"id": 11308, "price": {credit_types[7]: 7.0}, "description": "增加法力值",
                     "category": item_categories[2],
                     "icon": "🧪"},
        "活力卷轴": {"id": 11304, "price": {credit_types[3]: 9.0}, "description": "增加活力", "category": item_categories[4],
                     "icon": "📜"},
        "幸运宝箱": {"id": 11307, "price": {credit_types[6]: 5.0}, "description": "随机掉落物品", "category": item_categories[6],
                   "icon": "🎁","lootBoxes":[[{"count":1,"dropRate":0.02,"itemName":"超级经验书"},{"count":3,"dropRate":0.3,"itemName":"力量丸"},{"count":2,"dropRate":0.14,"itemName":"魔法药水"},{"count":1,"dropRate":0.14,"itemName":"全能药水"},{"count":2,"dropRate":0.14,"itemName":"生命药水"}]]},
        "超级经验书": {"id": 11309, "price": {credit_types[0]: 8.0, credit_types[6]: 4.0},
                       "description": "大幅增加经验值",
                       "category": item_categories[0], "icon": "📚"},
        "全能药水": {
            "id": 11310,
             "price": {credit_types[2]: 5.0, credit_types[3]: 5.0},
             "description": "同时恢复生命和法力",
             "category": item_categories[2],
             "icon": "🧴",
             "recipes": [[{"count":3,"itemName":"生命药水"},{"count":3,"itemName":"魔法药水"},{"count":1,"itemName":"活力卷轴"}]],
            }
    }

    return items

def generate_default_conversion_rates_deprecated():
    """根据设置动态生成默认转换比率"""
    settings = load_settings()
    credit_types = settings.get("creditTypes", ["智", "武", "体", "活", "敏", "灵", "A", "B"])

    # 如果积分类型数量不足，使用默认值
    if len(credit_types) < 8:
        return {
            "智→A": 1, "武→A": 1, "体→A": 1,
            "活→B": 1, "敏→B": 1, "灵→B": 1,
            "A→智": 1, "A→武": 1, "A→体": 1,
            "B→活": 1, "B→敏": 1, "B→灵": 1
        }

    # 动态生成转换比率
    rates = {}
    # 前3个转换为第7个(A)
    for i in range(3):
        rates[f"{credit_types[i]}→{credit_types[6]}"] = 1
    # 第4-6个转换为第8个(B)
    for i in range(3, 6):
        rates[f"{credit_types[i]}→{credit_types[7]}"] = 1
    # 反向转换
    rates[f"{credit_types[6]}→{credit_types[0]}"] = 1
    rates[f"{credit_types[6]}→{credit_types[1]}"] = 1
    rates[f"{credit_types[6]}→{credit_types[2]}"] = 1
    rates[f"{credit_types[7]}→{credit_types[3]}"] = 1
    rates[f"{credit_types[7]}→{credit_types[4]}"] = 1
    rates[f"{credit_types[7]}→{credit_types[5]}"] = 1

    return rates


# def load_settings_old():
#     """从文件加载设置"""
#     global _settings_cache
#
#     # 如果已有缓存，直接返回
#     if _settings_cache is not None:
#         return _settings_cache
#     try:
#         if os.path.exists(SETTINGS_FILE):
#             with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
#                 _settings_cache = json.load(f)
#                 return _settings_cache
#         else:
#             # 如果设置文件不存在，创建默认设置文件
#             save_settings(default_settings)
#             _settings_cache = default_settings
#             return _settings_cache
#     except Exception as e:
#         print(f"加载设置失败: {str(e)}")
#         _settings_cache = default_settings
#         return _settings_cache

def clear_settings_cache():
    """清除设置缓存，用于需要重新加载设置的场景"""
    config_manager._current_user_settings = None


# def save_settings_old(settings):
#     """保存设置到文件"""
#     try:
#         with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
#             json.dump(settings, f, ensure_ascii=False, indent=2)
#         return True
#     except Exception as e:
#         print(f"保存设置失败: {str(e)}")
#         return False



def get_default_data():
    """生成默认数据"""
    dynamic_items = generate_default_items()
    return {
        "stats": generate_default_stats(),
        "properties": generate_default_properties(),
        "credits": generate_default_credits(),
        "items": dynamic_items,
        "backpack": {item: 0 for item in dynamic_items},
        # "use_logs": [],
        # "conversion_rates": generate_default_conversion_rates(),
        "tasks": generate_default_tasks()
    }



# def load_data_old(allow_default=True):
#     """从文件加载数据"""
#     global _executing_auto_tasks
#     try:
#         data = None
#         if os.path.exists(DATA_FILE):
#             with open(DATA_FILE, 'r', encoding='utf-8') as f:
#                 data = json.load(f)
#
#             # 确保所有必需的字段都存在
#             stats = data.get("stats", generate_default_stats())
#             properties = data.get("properties", generate_default_properties())
#             credits = data.get("credits", generate_default_credits())
#             items = data.get("items", generate_default_items())
#             backpack = data.get("backpack", {item: 0 for item in items})
#             # use_logs = data.get("use_logs", [])
#             # conversion_rates = data.get("conversion_rates", generate_default_conversion_rates())
#             tasks = data.get("tasks", generate_default_tasks())
#             lootbox_miss_counts = data.get("lootbox_miss_counts", {})
#
#             # 处理旧数据兼容性
#             for task in tasks:
#                 if "task_type" not in task:
#                     task["task_type"] = "无循环"
#                 if "completed_count" not in task:
#                     task["completed_count"] = 0
#                 if "max_completions" not in task:
#                     task["max_completions"] = 0
#
#             result = {
#                 "stats": stats,
#                 "properties": properties,
#                 "credits": credits,
#                 "items": items,
#                 "backpack": backpack,
#                 # "use_logs": use_logs,
#                 # "conversion_rates": conversion_rates,
#                 "tasks": tasks,
#                 "lootbox_miss_counts":lootbox_miss_counts
#             }
#
#             # 在加载数据后执行自动任务检查（仅在非递归调用时执行）
#
#             if not _executing_auto_tasks:
#                 _executing_auto_tasks = True
#                 try:
#                     execute_daily_auto_tasks()
#                 finally:
#                     _executing_auto_tasks = False
#
#             return result
#         else:
#             # 使用动态生成的默认数据
#             if allow_default:
#                 print("数据文件不存在，已启用默认数据")
#                 result = get_default_data()
#                 # 对于新数据也执行自动任务检查
#                 if not _executing_auto_tasks:
#                     _executing_auto_tasks = True
#                     try:
#                         execute_daily_auto_tasks()
#                     finally:
#                         _executing_auto_tasks = False
#                 return result
#             else:
#                 print(f"数据文件不存在: {DATA_FILE}")
#                 raise FileNotFoundError
#
#     except Exception as e:
#         # 使用动态生成的默认数据
#         if allow_default:
#             print(f"加载数据失败: {str(e)}\n 已启用默认数据")
#             result = get_default_data()
#             # 对于出错情况也执行自动任务检查
#             if not _executing_auto_tasks:
#                 _executing_auto_tasks = True
#                 try:
#                     execute_daily_auto_tasks()
#                 finally:
#                     _executing_auto_tasks = False
#             return result
#         else:
#             print(f"加载数据失败: {str(e)}")
#             raise e


def get_auto_task_status():
    """获取自动任务执行状态"""
    try:
        # 使用 allow_default=False 避免递归调用
        data = load_data(allow_default=False)

        # 检查是否存在自动任务日志字段
        if "auto_task_log" not in data:
            return {}

        return data["auto_task_log"]
    except Exception as e:
        print(f"获取自动任务状态失败: {str(e)}")
        return {}


def update_auto_task_status(task_type):
    """更新自动任务执行状态"""
    try:
        data = load_data()

        # 确保自动任务日志字段存在
        if "auto_task_log" not in data:
            data["auto_task_log"] = {}

        # 更新对应任务的执行时间
        current_date = date.today().isoformat()
        if task_type == "archive":
            data["auto_task_log"]["last_archive_date"] = current_date
        elif task_type == "recycle":
            data["auto_task_log"]["last_recycle_date"] = current_date

        # 保存数据
        if safe_save_data(data):
            print(f"自动任务状态已更新: {task_type} 任务执行时间已设置为 {current_date}")
            return True
        else:
            print("保存自动任务状态失败")
            return False
    except Exception as e:
        print(f"更新自动任务状态失败: {str(e)}")
        return False


def should_execute_auto_task(task_type):
    """检查是否应该执行自动任务"""
    try:
        auto_task_log = get_auto_task_status()
        current_date = date.today().isoformat()

        # 检查对应任务的最后执行日期
        if task_type == "archive":
            last_execution_date = auto_task_log.get("last_archive_date")
        elif task_type == "recycle":
            last_execution_date = auto_task_log.get("last_recycle_date")
        else:
            return False

        # 如果最后执行日期不等于今天，则应该执行
        # 注意：这里需要判断 last_execution_date 是否存在，如果不存在则应该执行
        if last_execution_date is None:
            return True  # 从未执行过，应该执行

        return last_execution_date != current_date
    except Exception as e:
        print(f"检查自动任务执行条件失败: {str(e)}")
        # 出错时默认不执行，防止重复执行
        return False


_execute_auto_task_cnt = 0
# _should_execute_auto_task = False
# def get_bool_for_auto_task():
#     global _should_execute_auto_task
#     _should_execute_auto_task = {"bool_auto_task_archive":should_execute_auto_task("archive"),"bool_auto_task_recycle":should_execute_auto_task("recycle")}
#     return _should_execute_auto_task

def execute_daily_auto_tasks():
    """执行每日自动任务"""
    global _execute_auto_task_cnt
    try:
        if _execute_auto_task_cnt > 0:
            print("已执行过自动任务，请勿重复执行")
            return
        print("开始检查并执行每日自动任务...")


        # 标记本次执行中哪些任务被执行了
        archive_executed = False
        recycle_executed = False

        # 检查并执行批量归档任务
        if should_execute_auto_task("archive"):
            print("执行批量归档任务...")
            # 直接调用函数而不是使用API端点
            archived_count = batch_archive_tasks()
            if archived_count >= 0:  # batch_archive_tasks 返回数字
                update_auto_task_status("archive")
                archive_executed = True
                print(f"批量归档任务完成，共归档 {archived_count} 个任务")
            else:
                print("批量归档任务执行失败")
        else:
            print("今日已执行过批量归档任务，跳过执行")

        # 检查并执行循环任务刷新
        if should_execute_auto_task("recycle"):
            print("执行循环任务刷新...")
            # 直接调用函数而不是使用API端点
            updated_count = check_and_update_cycle_tasks()
            if updated_count >= 0:  # check_and_update_cycle_tasks 返回数字
                update_auto_task_status("recycle")
                recycle_executed = True
                print(f"循环任务刷新完成，共更新 {updated_count} 个任务")
            else:
                print("循环任务刷新执行失败")
        else:
            print("今日已执行过循环任务刷新，跳过执行")
        # 如果今天执行了任何任务，可以记录日志
        if archive_executed or recycle_executed:
            print(f"今日自动任务执行完成: 归档={archive_executed}, 循环刷新={recycle_executed}")

        _execute_auto_task_cnt += 1

    except Exception as e:
        print(f"执行每日自动任务时出错: {str(e)}")


# def save_data_old(data):
#     """保存数据到文件"""
#     try:
#         with open(DATA_FILE, 'w', encoding='utf-8') as f:
#             json.dump(data, f, ensure_ascii=False, indent=2)
#         return True
#     except Exception as e:
#         print(f"保存数据失败: {str(e)}")
#         return False


def safe_save_data(data,max_different_fields=2, max_different_items_per_field=10, enable_single_field_max_check=True,skip_check=False):
    """带内容完整性检查的安全数据保存"""
    try:
        max_different_fields = MAX_DIFFERENT_FIELDS if MAX_DIFFERENT_FIELDS else max_different_fields
        max_different_items_per_field = MAX_DIFFERENT_ITEMS_PER_FIELD if MAX_DIFFERENT_ITEMS_PER_FIELD else max_different_items_per_field

        # 加载原始数据用于对比
        original_data = load_data(allow_default=False)

        # 验证数据结构完整性
        validate_data_structure(data)

        # 验证内容完整性
        is_valid, info = check_content_integrity(original_data, data,max_different_fields=max_different_fields, max_different_items_per_field=max_different_items_per_field,enable_single_field_max_check=enable_single_field_max_check,skip_check=skip_check)
        if not is_valid:
            error_msg = f"数据内容完整性验证失败: 超过阈值的字段数量={info['different_fields_count']}, " \
                        f"最大允许字段数={info['max_allowed_different_fields']}"
            raise ValueError(error_msg)

        # 智能备份
        backup_file = smart_backup_data()

        # 保存数据
        if save_data(data):
            return True
        else:
            # 如果保存失败，尝试从备份恢复
            if backup_file:
                restore_data_from_backup(backup_file)
            return False

    except ValueError as e:
        print(f"数据验证失败: {str(e)}")
        return False
    except Exception as e:
        print(f"保存数据时发生错误: {str(e)}")
        return False

# 数据备份机制

def backup_data():
    """创建数据备份"""
    try:
        if os.path.exists(config_manager.DATA_FILE):
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = f"{config_manager.DATA_FILE}.backup_{timestamp}"
            shutil.copy2(config_manager.DATA_FILE, backup_file)
            print(f"数据备份创建成功: {backup_file}")
            return backup_file
        return None
    except Exception as e:
        print(f"创建数据备份失败: {str(e)}")
        return None

def smart_backup_data():
    """智能备份：结合时间间隔控制和数量限制"""
    global _last_backup_time

    try:
        if not os.path.exists(config_manager.DATA_FILE):
            return None

        current_time = time.time()

        # 检查是否需要创建新备份
        should_backup = False
        if _last_backup_time is None:
            should_backup = True  # 首次备份
        elif (current_time - _last_backup_time) >= _backup_interval:
            should_backup = True  # 超过时间间隔
        else:
            print("跳过备份：距离上次备份时间不足")
            return None

        if should_backup:
            # 创建新备份
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = f"{config_manager.DATA_FILE}.backup_{timestamp}"
            shutil.copy2(config_manager.DATA_FILE, backup_file)
            _last_backup_time = current_time
            print(f"数据备份创建成功: {backup_file}")

            # 清理旧备份
            cleanup_old_backups()

            return backup_file

    except Exception as e:
        print(f"创建数据备份失败: {str(e)}")
        return None


def cleanup_old_backups():
    """清理旧的备份文件"""
    try:
        backup_pattern = f"{config_manager.DATA_FILE}.backup_*"
        backup_files = glob.glob(backup_pattern)

        # 按修改时间排序（最新的在前）
        backup_files.sort(key=os.path.getmtime, reverse=True)

        # 删除超过最大数量的旧备份
        for old_backup in backup_files[_max_backups:]:
            try:
                os.remove(old_backup)
                print(f"删除旧备份文件: {old_backup}")
            except Exception as e:
                print(f"删除备份文件失败 {old_backup}: {str(e)}")

    except Exception as e:
        print(f"清理旧备份文件时出错: {str(e)}")


def restore_data_from_backup(backup_file):
    """从备份恢复数据"""
    try:
        if os.path.exists(backup_file):
            shutil.copy2(backup_file, config_manager.DATA_FILE)
            print(f"数据从备份恢复成功: {backup_file}")
            return True
        return False
    except Exception as e:
        print(f"从备份恢复数据失败: {str(e)}")
        return False







# 如果文件树文件不存在，创建一个空的
def init_default_file_tree():
    """初始化文件树结构"""
    if hasattr(config_manager, 'MARKDOWN_TREE_FILE'):
        if not os.path.exists(config_manager.MARKDOWN_TREE_FILE):
            default_tree = create_default_file_tree()
            try:
                with open(config_manager.MARKDOWN_TREE_FILE, 'w', encoding='utf-8') as f:
                    json.dump(default_tree, f, ensure_ascii=False, indent=2)
            except Exception as e:
                print(f"创建默认文件树文件失败: {str(e)}")


init_default_file_tree()
# def save_file_tree_old(tree):
#     """保存文件树结构"""
#     try:
#         print("正在保存文件树结构...")
#         with open(MARKDOWN_TREE_FILE, 'w', encoding='utf-8') as f:
#             json.dump(tree, f, ensure_ascii=False, indent=2)
#         print("文件树保存成功")
#         return True
#     except Exception as e:
#         print(f"保存文件树失败: {str(e)}")
#         return False

# def get_file_path_old(file_id):
#     """获取文件在磁盘上的路径"""
#     return os.path.join(NOTES_DIR, f"{file_id}.md")
#
# def get_journal_path_old(file_id):
#     """获取JNL文件在磁盘上的路径"""
#     return os.path.join(JOURNALS_DIR, f"{file_id}.md")


def load_file_content(file_id):
    """加载文件内容"""
    try:
        file_path = get_file_path(file_id)
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        return ""
    except Exception as e:
        print(f"加载文件内容失败: {str(e)}")
        return ""

def save_file_content(file_id, content):
    """保存文件内容"""
    try:
        file_path = get_file_path(file_id)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        return True
    except Exception as e:
        print(f"保存文件内容失败: {str(e)}")
        return False

def delete_file_content(file_id):
    """删除文件内容"""
    try:
        file_path = get_file_path(file_id)
        if os.path.exists(file_path):
            os.remove(file_path)
        return True
    except Exception as e:
        print(f"删除文件内容失败: {str(e)}")
        return False

# 添加数据完整性检查函数
def validate_data_structure(data):
    """验证数据结构的完整性"""
    required_fields = ["stats", "properties", "credits", "items", "backpack",  "tasks"]

    # 检查必需字段是否存在
    for field in required_fields:
        if field not in data:
            raise ValueError(f"缺少必需字段: {field}")

    # 验证 properties 是否为列表
    if not isinstance(data.get("properties", {}), dict):
        raise ValueError("properties 必须是字典类型")

    # 验证 credits 是否为字典
    if not isinstance(data.get("credits", {}), dict):
        raise ValueError("credits 必须是字典类型")

    # 验证 tasks 是否为列表
    if not isinstance(data.get("tasks", []), list):
        raise ValueError("tasks 必须是列表类型")

    return True



# 添加图片文件管理函数
def get_used_images_in_notes():
    """获取所有笔记中引用的图片文件名"""
    try:
        used_images = set()
        tree = load_file_tree()

        def extract_images_from_node(node):
            if node["type"] == "file":
                content = load_file_content(node["id"])
                # 查找Markdown图片语法 ![alt](url)
                import re
                image_patterns = re.findall(r'!\[.*?\]\((.*?)\)', content)
                for url in image_patterns:
                    # 如果是本地图片URL，提取文件名
                    if '/files/images/' in url:
                        filename = url.split('/')[-1]
                        used_images.add(filename)
            elif node["type"] == "folder" and "children" in node:
                for child in node["children"]:
                    extract_images_from_node(child)

        for node in tree:
            extract_images_from_node(node)

        return list(used_images)
    except Exception as e:
        print(f"获取使用中的图片失败: {str(e)}")
        return []

# def get_all_image_files_old():
#     """获取所有图片文件"""
#     try:
#         image_files = []
#         if os.path.exists(IMAGES_DIR):
#             for filename in os.listdir(IMAGES_DIR):
#                 if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
#                     file_path = os.path.join(IMAGES_DIR, filename)
#                     image_files.append({
#                         "name": filename,
#                         "size": os.path.getsize(file_path),
#                         "modified": datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat()
#                     })
#         return image_files
#     except Exception as e:
#         print(f"获取图片文件列表失败: {str(e)}")
#         return []


# def check_content_integrity(original_data, new_data):
#     """检查数据内容完整性，通过关键字段对比验证"""
#
#     # 提取原始数据的关键内容
#     original_items_keys = set(original_data.get("items", {}).keys())
#     original_task_names = set(task.get("name", "") for task in original_data.get("tasks", []))
#
#     # 提取新数据的关键内容
#     new_items_keys = set(new_data.get("items", {}).keys())
#     new_task_names = set(task.get("name", "") for task in new_data.get("tasks", []))
#
#     # 计算相似度（简单对比方法）
#     items_similarity = calculate_simple_similarity(original_items_keys, new_items_keys)
#     tasks_similarity = calculate_simple_similarity(original_task_names, new_task_names)
#
#     # 设定阈值（可根据需要调整）
#     threshold = 0.8
#
#     if items_similarity < threshold or tasks_similarity < threshold:
#         return False, {
#             "items_similarity": items_similarity,
#             "tasks_similarity": tasks_similarity,
#             "threshold": threshold
#         }
#
#     return True, {
#         "items_similarity": items_similarity,
#         "tasks_similarity": tasks_similarity
#     }
#
# def calculate_simple_similarity(set1, set2):
#     """计算两个集合的简单相似度"""
#     if not set1 and not set2:
#         return 1.0
#
#     if not set1 or not set2:
#         return 0.0
#
#     # 使用交集与并集的比例作为相似度
#     intersection = len(set1.intersection(set2))
#     union = len(set1.union(set2))
#
#     return intersection / union if union > 0 else 0.0


def check_content_integrity(original_data, new_data, max_different_fields=2, max_different_items_per_field=100, enable_single_field_max_check=True, skip_check=False):
    """检查数据内容完整性，通过字段数据项数量差异验证"""

    # 如果明确要求跳过检查，则直接返回True
    if skip_check:
        return True, {
            "message": "检查已跳过",
            "different_fields_count": 0,
            "overdifferent_fields_count": 0
        }

    # 定义需要检查的关键字段
    key_fields = ["items", "tasks"]

    # 定义阈值
    max_different_fields = max_different_fields  # A阈值: 允许有差异的字段数量
    max_different_items_per_field = max_different_items_per_field  # B阈值: 单个字段下允许的最大差异数

    # 统计各字段的数据项数量
    field_differences = {}

    # 通用字段检查逻辑
    for field in key_fields:
        original_field_data = original_data.get(field, {})
        new_field_data = new_data.get(field, {})

        # 根据数据类型计算数量
        if isinstance(original_field_data, dict):
            original_count = len(original_field_data.keys())
        elif isinstance(original_field_data, list):
            original_count = len(original_field_data)
        else:
            original_count = 1 if original_field_data else 0

        if isinstance(new_field_data, dict):
            new_count = len(new_field_data.keys())
        elif isinstance(new_field_data, list):
            new_count = len(new_field_data)
        else:
            new_count = 1 if new_field_data else 0

        # 计算差异
        difference = abs(original_count - new_count)
        field_differences[field] = {
            "original_count": original_count,
            "new_count": new_count,
            "difference": difference
        }

    # 统计有差异的字段数量
    different_fields_count = 0
    overdifferent_fields_count = 0

    for field in key_fields:
        difference = field_differences[field]["difference"]
        if difference > 0:
            different_fields_count += 1
        if enable_single_field_max_check:
            if difference > max_different_items_per_field:
                overdifferent_fields_count += 1

    # 检查是否违反阈值规则
    # 条件1: 有差异的字段数量超过A阈值（差异大于0的字段数超过A）
    # 条件2: 单字段差异数超过B阈值（差异大于B阈值的字段数超过1）
    if different_fields_count > max_different_fields or overdifferent_fields_count > 0:
        return False, {
            "field_differences": field_differences,
            "different_fields_count": different_fields_count,
            "overdifferent_fields_count": overdifferent_fields_count,
            "max_allowed_different_fields": max_different_fields,
            "max_allowed_difference_per_field": max_different_items_per_field
        }

    return True, {
        "field_differences": field_differences,
        "different_fields_count": different_fields_count,
        "overdifferent_fields_count": overdifferent_fields_count
    }

# API路由

# @app.route('/')
# def index():
#     return send_from_directory('build', 'index.html')
#
#
# @app.route('/static/<path:path>')
# def serve_static(path):
#     return send_from_directory('build/static', path)















# 更新API路由函数以使用全局配置
@app.route('/api/logs', methods=['GET'])
@token_required()
def get_logs():
    """获取日志"""
    try:
        if hasattr(config_manager, 'LOGS_FILE'):
            if os.path.exists(config_manager.LOGS_FILE):
                with open(config_manager.LOGS_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return jsonify({'logs': data.get('logs', {})})
        return jsonify({'logs': []})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/save', methods=['POST'])
@token_required()
def save_logs():
    """保存日志"""
    try:
        data = request.json
        with open(config_manager.LOGS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return jsonify({'message': '日志保存成功'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500




# 用户认证路由
@app.route('/api/auth/register', methods=['POST'])
def register():
    """用户注册"""
    # print('registering...')
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    # print(("用户注册:", username, password))

    if not username or not password:
        return jsonify({'error': 'Username and password are required'}), 400

    if len(username) < 3 or len(username) > 20:
        return jsonify({'error': 'Username must be between 3 and 20 characters'}), 400

    if len(password) < 4:
        return jsonify({'error': 'Password must be at least 4 characters'}), 400

    users_db = get_user_db()
    if username in users_db:
        return jsonify({'error': 'User already exists'}), 400

    # 密码哈希
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

    users_db[username] = {
        'password': hashed_password,
        'id': str(uuid.uuid4()),
        'created_at': datetime.now().isoformat(),
        'permissions': ['user']  # 默认权限
    }
    save_user_db(users_db)
    # print("用户数据保存成功:", users_db[username])

    # 初始化用户数据
    init_user_data(username)

    return jsonify({'message': 'User registered successfully'})


# @app.route('/api/auth/login', methods=['POST'])
# def login():
#     """用户登录"""
#     data = request.get_json()
#     username = data.get('username')
#     password = data.get('password')
#     # print("用户登录:", username, password)
#
#     if not username or not password:
#         return jsonify({'error': 'Username and password are required'}), 400
#
#     users_db = get_user_db()
#     if username not in users_db:
#         return jsonify({'error': '用户名或密码错误！'}), 401
#
#     stored_hash = users_db[username]['password']
#     # print("存储的密码:", stored_hash)
#
#     # 检查存储的密码是否是 bcrypt 格式
#     try:
#         # bcrypt 哈希总是以 $2 开头
#         if stored_hash.startswith('$2'):
#             # 使用 bcrypt 验证
#             if not bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8')):
#                 return jsonify({'error': '用户名或密码错误！'}), 401
#         else:
#             # 如果不是 bcrypt 格式，可能是旧的 SHA256 格式或其他格式
#             return jsonify({'error': '用户名或密码错误！'}), 401
#     except ValueError as e:
#         print(f"密码验证错误: {str(e)}")
#         return jsonify({'error': '用户名或密码错误！'}), 401
#
#     # 生成令牌
#     access_token, refresh_token = generate_tokens(username)
#
#     res = jsonify({
#         'message': 'Login successful',
#         'username': username,
#         'access_token': access_token,
#         'refresh_token': refresh_token
#     })
#     return res

@app.route('/api/auth/login', methods=['POST'])
def login():
    """用户登录"""
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    long_term = data.get('remember_me', False)  # 添加记住登录选项

    if not username or not password:
        return jsonify({'error': 'Username and password are required'}), 400

    users_db = get_user_db()
    if username not in users_db:
        return jsonify({'error': 'Invalid credentials'}), 401

    stored_hash = users_db[username]['password']
    if not bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8')):
        return jsonify({'error': 'Invalid credentials'}), 401

    # 生成令牌，根据remember_me参数决定过期时间
    access_token, refresh_token = generate_tokens(username, long_term=long_term)

    return jsonify({
        'message': 'Login successful',
        'username': username,
        'access_token': access_token,
        'refresh_token': refresh_token,
        'long_term': long_term
    })

@app.route('/api/auth/refresh', methods=['POST'])
def refresh():
    """刷新访问令牌"""
    refresh_token = request.json.get('refresh_token')
    if not refresh_token:
        return jsonify({'error': 'Refresh token is missing'}), 400

    username = verify_token(refresh_token)
    if not username:
        return jsonify({'error': 'Invalid or expired refresh token'}), 401

    # 生成新的令牌对
    new_access_token, new_refresh_token = generate_tokens(username)

    return jsonify({
        'access_token': new_access_token,
        'refresh_token': new_refresh_token
    })


@app.route('/api/auth/logout', methods=['POST'])
@token_required()
def logout():
    """用户登出"""
    # 在实际应用中，可能需要将令牌加入黑名单
    return jsonify({'message': 'Logout successful'})


@app.route('/api/user/profile', methods=['GET'])
@token_required()
def get_profile():
    """获取用户资料"""
    username = request.current_user
    users_db = get_user_db()
    user_info = users_db.get(username, {})

    # 移除敏感信息
    user_info.pop('password', None)

    return jsonify({
        'username': username,
        'profile': user_info
    })


# 获取所有用户列表的路由
@app.route('/api/users', methods=['GET'])
@token_required()
def api_get_users():
    """获取所有用户列表（仅管理员可访问）"""
    try:
        # 检查当前用户是否为管理员
        current_user = request.current_user
        if not current_user:
            return jsonify({'error': 'Authentication required'}), 401

        # 检查权限
        user_permissions = get_user_permissions(current_user)
        if 'admin' not in user_permissions:
            return jsonify({'error': 'Permission denied'}), 403

        # 读取用户数据库
        if not os.path.exists(USERS_DB_FILE):
            return jsonify({'users': []})

        with open(USERS_DB_FILE, 'r') as f:
            users_db = json.load(f)

        # 构造返回数据，不包含密码等敏感信息
        users_list = []
        for username, user_info in users_db.items():
            users_list.append({
                'username': username,
                'permissions': user_info.get('permissions', []),
                'created_at': user_info.get('created_at')
            })

        return jsonify({'users': users_list})
    except Exception as e:
        print(f"获取用户列表失败: {str(e)}")
        return jsonify({'error': '获取用户列表失败'}), 500


# 修改创建新用户的路由函数
@app.route('/api/users', methods=['POST'])
@token_required()
def api_create_user():
    """创建新用户（仅管理员可访问）"""
    try:
        # 检查当前用户是否为管理员
        current_user = request.current_user
        if not current_user:
            return jsonify({'error': '需要身份验证'}), 401

        # 检查权限
        user_permissions = get_user_permissions(current_user)
        if 'admin' not in user_permissions:
            return jsonify({'error': '权限不足'}), 403

        # 获取请求数据
        data = request.json
        username = data.get('username')
        password = data.get('password')
        permissions = data.get('permissions', ['user'])  # 从请求数据中获取权限，默认为普通用户

        if not username or not password:
            return jsonify({'error': 'Username and password are required'}), 400

        # 验证权限字段
        if not isinstance(permissions, list):
            return jsonify({'error': 'Permissions must be a list'}), 400

        # 检查权限有效性（只能设置'user'或'admin'权限）
        valid_permissions = {'user', 'admin'}
        if not all(permission in valid_permissions for permission in permissions):
            return jsonify({'error': 'Invalid permissions'}), 400

        # 检查用户名是否已存在
        if not os.path.exists(USERS_DB_FILE):
            users_db = {}
        else:
            with open(USERS_DB_FILE, 'r') as f:
                users_db = json.load(f)

        if username in users_db:
            return jsonify({'error': 'Username already exists'}), 400

        # 创建新用户
        # hashed_password = hashlib.sha256(password.encode()).hexdigest()
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        users_db[username] = {
            'password': hashed_password,
            'permissions': permissions,  # 使用从前端传递的权限
            'created_at': datetime.now().isoformat()
        }

        # 保存用户数据库
        with open(USERS_DB_FILE, 'w') as f:
            json.dump(users_db, f)

        # 创建用户目录
        user_dir = get_user_dir(username)
        os.makedirs(user_dir, exist_ok=True)

        # 返回新创建的用户信息
        return jsonify({
            'user': {
                'username': username,
                'permissions': permissions,  # 返回设置的权限
                'created_at': users_db[username]['created_at']
            }
        }), 201

    except Exception as e:
        print(f"创建用户失败: {str(e)}")
        return jsonify({'error': '创建用户失败'}), 500


# 删除用户的路由
@app.route('/api/users/<username>', methods=['DELETE'])
@token_required()
def api_delete_user(username):
    """删除用户（仅管理员可访问）"""
    try:
        # 检查当前用户是否为管理员
        current_user = request.current_user
        if not current_user:
            return jsonify({'error': 'Authentication required'}), 401

        # 检查权限
        user_permissions = get_user_permissions(current_user)
        if 'admin' not in user_permissions:
            return jsonify({'error': 'Permission denied'}), 403

        # 不能删除自己
        if current_user == username:
            return jsonify({'error': 'Cannot delete yourself'}), 400

        # 读取用户数据库
        if not os.path.exists(USERS_DB_FILE):
            return jsonify({'error': 'User not found'}), 404

        with open(USERS_DB_FILE, 'r') as f:
            users_db = json.load(f)

        # 检查用户是否存在
        if username not in users_db:
            return jsonify({'error': 'User not found'}), 404

        # 删除用户
        del users_db[username]

        # 保存用户数据库
        with open(USERS_DB_FILE, 'w') as f:
            json.dump(users_db, f)

        # 可选择性地删除用户目录及其所有数据
        user_dir = get_user_dir(username)
        if os.path.exists(user_dir):
            shutil.rmtree(user_dir)

        return jsonify({'message': f'User {username} deleted successfully'}), 200

    except Exception as e:
        print(f"删除用户失败: {str(e)}")
        return jsonify({'error': '删除用户失败'}), 500


# 更新用户信息的路由
@app.route('/api/users/<username>', methods=['PUT'])
@token_required()
def api_update_user(username):
    """更新用户信息（支持更新密码和权限）"""
    try:
        # 检查当前用户是否为管理员
        current_user = request.current_user
        if not current_user:
            return jsonify({'error': 'Authentication required'}), 401

        # 检查权限
        user_permissions = get_user_permissions(current_user)
        if 'admin' not in user_permissions:
            return jsonify({'error': 'Permission denied'}), 403

        # 获取请求数据
        data = request.json

        # 检查是否提供了需要更新的字段
        password = data.get('password')
        permissions = data.get('permissions')

        if password is None and permissions is None:
            return jsonify({'error': 'Password or permissions is required'}), 400

        # 读取用户数据库
        if not os.path.exists(USERS_DB_FILE):
            return jsonify({'error': 'User not found'}), 404

        with open(USERS_DB_FILE, 'r') as f:
            users_db = json.load(f)

        # 检查用户是否存在
        if username not in users_db:
            return jsonify({'error': 'User not found'}), 404

        # 更新密码（如果提供了）
        if password is not None:
            if len(password) < 4:
                return jsonify({'error': 'Password must be at least 4 characters'}), 400
            # hashed_password = hashlib.sha256(password.encode()).hexdigest()
            hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            users_db[username]['password'] = hashed_password

        # 更新权限（如果提供了）
        if permissions is not None:
            # 验证权限字段
            if not isinstance(permissions, list):
                return jsonify({'error': 'Permissions must be a list'}), 400

            # 检查权限有效性
            valid_permissions = {'user', 'admin'}
            if not all(permission in valid_permissions for permission in permissions):
                return jsonify({'error': 'Invalid permissions'}), 400

            users_db[username]['permissions'] = permissions

        # 保存用户数据库
        with open(USERS_DB_FILE, 'w') as f:
            json.dump(users_db, f)

        return jsonify({'message': f'User {username} updated successfully'}), 200

    except Exception as e:
        print(f"更新用户失败: {str(e)}")
        return jsonify({'error': '更新用户失败'}), 500


# 确保辅助函数已定义
def get_user_permissions(username):
    """获取用户权限列表"""
    try:
        if not os.path.exists(USERS_DB_FILE):
            return []

        with open(USERS_DB_FILE, 'r') as f:
            users_db = json.load(f)

        if username in users_db:
            return users_db[username].get('permissions', [])
        return []
    except Exception as e:
        print(f"获取用户权限失败: {str(e)}")
        return []


# 添加修改密码的路由
@app.route('/api/user/change-password', methods=['PUT'])
@token_required()
def change_password():
    """修改用户密码"""
    try:
        # 获取当前用户
        current_user = request.current_user
        if not current_user:
            return jsonify({'error': 'Authentication required'}), 401

        # 获取请求数据
        data = request.get_json()
        old_password = data.get('old_password')
        new_password = data.get('new_password')

        # 验证输入
        if not old_password or not new_password:
            return jsonify({'error': 'Old password and new password are required'}), 400

        if len(new_password) < 4:
            return jsonify({'error': 'New password must be at least 4 characters'}), 400

        # 获取用户数据库
        users_db = get_user_db()

        # 检查用户是否存在
        if current_user not in users_db:
            return jsonify({'error': 'User not found'}), 404

        # 验证原密码
        stored_hash = users_db[current_user]['password']

        # 检查存储的密码是否是 bcrypt 格式
        if stored_hash.startswith('$2'):
            # 使用 bcrypt 验证
            if not bcrypt.checkpw(old_password.encode('utf-8'), stored_hash.encode('utf-8')):
                return jsonify({'error': 'Old password is incorrect'}), 400
        else:
            # 如果不是 bcrypt 格式，可能是旧的 SHA256 格式
            old_password_hash = hashlib.sha256(old_password.encode()).hexdigest()
            if old_password_hash != stored_hash:
                return jsonify({'error': 'Old password is incorrect'}), 400

        # 生成新密码的哈希
        new_hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

        # 更新密码
        users_db[current_user]['password'] = new_hashed_password

        # 保存用户数据库
        save_user_db(users_db)

        return jsonify({'message': 'Password changed successfully'}), 200

    except Exception as e:
        print(f"修改密码失败: {str(e)}")
        return jsonify({'error': 'Failed to change password'}), 500



























@app.route('/api/default-settings', methods=['GET'])
def get_default_settings():
    """获取默认设置"""
    return jsonify(default_settings)



@app.route('/api/settings', methods=['GET'])
@token_required()
def get_settings():
    """获取设置"""
    settings = load_settings()
    # 确保文件存储配置存在
    if "fileStorage" not in settings:
        settings["fileStorage"] = {"mountPath": "/files"}
    return jsonify(settings)

@app.route('/api/settings', methods=['PUT'])
# @token_required()
def update_settings():
    """更新设置"""
    settings_data = request.json
    print("接收到设置数据:")  # 添加调试日志
    if save_settings(settings_data):
        # 清除缓存以确保下次加载的是最新设置
        clear_settings_cache()
        return jsonify({"message": "设置已保存"})
    else:
        return jsonify({"error": "保存设置失败"}), 500

@app.route('/')
def index():
    return jsonify({"message": "GLifeist API Server is running"})


@app.route('/api/data', methods=['GET'])
@token_required()
def get_data():
    """获取所有数据"""
    data = load_data()
    return jsonify(data)



@app.route('/api/character/info', methods=['PUT'])
@token_required()
def update_character_info():
    """更新角色信息（名称和图标）"""
    try:
        data = load_data()
        character_info = request.json
        print("接收到的角色信息:", character_info)

        # 确保 stats 存在
        if "stats" not in data:
            data["stats"] = {}

        # 更新角色名称
        if "name" in character_info:
            data["stats"]["name"] = character_info["name"]

        # 更新角色图标
        if "avatar" in character_info:
            data["stats"]["avatar"] = character_info["avatar"]

        # 保存数据
        if safe_save_data(data):
            return jsonify({"message": "角色信息已更新"})
        else:
            return jsonify({"error": "保存数据失败"}), 500

    except Exception as e:
        print(f"更新角色信息时发生错误: {str(e)}")
        return jsonify({"error": f"服务器内部错误: {str(e)}"}), 500

@app.route('/api/character/exp', methods=['POST'])
def add_character_exp():
    """增加角色经验值"""
    data = load_data()
    amount = request.json.get('amount', 0)

    if amount <= 0:
        return jsonify({"error": "经验值必须大于0"}), 400

    # 假设经验值存储在 credits 中的 "经验" 类型里
    if "exp" not in data["stats"]:
        data["stats"]["exp"] = 0

    exp = data["stats"]["exp"] + amount

    # 计算等级
    settings = load_settings()
    a = settings['expFormulas'].get('levelUpA',100)
    n = settings['expFormulas'].get('levelUpN', 2.5)
    level = math.floor((exp / a) ** (1 / n)) + 1

    data["stats"]["exp"] = exp
    data["stats"]["level"] = level

    if safe_save_data(data):
        return jsonify({"message": f"经验值增加{amount}点，当前总计{data['stats']['exp']}点"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/character/properties/<property_category>', methods=['POST'])
def add_character_property(property_category):
    """增加角色属性点"""
    try:
        # URL解码中文字符
        property_category = unquote(property_category)
        print(f"接收到更新属性请求: {property_category}")

        data = load_data()
        amount = request.json.get('amount', 0)
        print(f"更新量: {amount}")

        if amount <= 0:
            return jsonify({"error": "属性点必须大于0"}), 400


        # 确保 properties 是一个字典
        if "properties" not in data or not isinstance(data["properties"], dict):
            data["properties"] = generate_default_properties()
            print("初始化 properties 为字典")

        # 更新属性值
        if property_category in data["properties"]:
            data["properties"][property_category] += amount
            print(f"找到属性并更新: {property_category} = {data['properties'][property_category]}")
        else:
            print(f"未找到属性，创建新属性: {property_category}")
            data["properties"][property_category] = amount

        #
        # # 确保 properties 是一个列表
        # if "properties" not in data or not isinstance(data["properties"], list):
        #     data["properties"] = []
        #     print("初始化 properties 为列表")
        #
        # # 查找匹配的属性类别
        # property_found = False
        # for prop in data["properties"]:
        #     # 确保 prop 是字典类型
        #     if isinstance(prop, dict) and prop.get("name") == property_category:
        #         prop["value"] = prop.get("value", 0) + amount
        #         property_found = True
        #         print(f"找到属性并更新: {prop}")
        #         break
        #
        # # 如果没找到该属性类别，创建一个新的
        # if not property_found:
        #     print(f"未找到属性，创建新属性: {property_category}")
        #     data["properties"].append({
        #         "name": property_category,
        #         "value": amount,
        #         "icon": ""
        #     })

        if safe_save_data(data):
            return jsonify({"message": f"{property_category}属性增加{amount}点"})
        else:
            return jsonify({"error": "保存数据失败"}), 500
    except Exception as e:
        print(f"更新属性时发生错误: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": f"服务器内部错误: {str(e)}"}), 500


@app.route('/api/character/stats', methods=['GET'])
@token_required()
def get_character_stats():
    """获取角色属性数据"""
    data = load_data()
    return jsonify(data["stats"])

@app.route('/api/credits', methods=['GET'])
def get_credits():
    """获取积分数据"""
    data = load_data()
    return jsonify(data["credits"])

# 通过url参数更新积分数据
@app.route('/api/credits/add/<credit_type>/<amount>', methods=['POST'])
def add_credit(credit_type, amount):
    """通过URL参数新增积分"""
    try:
        # URL解码中文字符
        credit_type = unquote(credit_type)

        # 尝试转换为浮点数
        amount_value = float(amount)
    except ValueError:
        return jsonify({"error": "积分数量必须是有效数字"}), 400
    except UnicodeDecodeError:
        return jsonify({"error": "积分类型字符编码错误"}), 400

    data = load_data()

    # 验证积分类型是否存在
    if credit_type not in data["credits"]:
        # 如果是新的积分类型，初始化为0
        data["credits"][credit_type] = 0.0

    # 新增积分（而不是直接设置）
    data["credits"][credit_type] += amount_value

    if safe_save_data(data):
        return jsonify({
            "message": f"{credit_type}积分新增{amount_value}点，当前总计{data['credits'][credit_type]}点"
        })
    else:
        return jsonify({"error": "保存数据失败"}), 500

@app.route('/api/credits/<credit_type>', methods=['PUT'])
def update_credit(credit_type):
    """更新积分"""
    data = load_data()
    amount = request.json.get('amount')

    if amount < 0:
        return jsonify({"error": "积分不能为负数"}), 400

    data["credits"][credit_type] = amount

    if safe_save_data(data):
        # 打印
        return jsonify({"message": f"{credit_type}积分已更新为{amount}"})
    else:
        return jsonify({"error": "保存数据失败"}), 500

# 转换积分 (to be deprecated)
@app.route('/api/credits/conversion', methods=['POST'])
def convert_credits():
    """转换积分"""
    data = load_data()
    convert_type = request.json.get('convert_type')
    amount = request.json.get('amount')

    if "→" in convert_type:
        src_type, dest_type = convert_type.split("→")
        rate = data["conversion_rates"].get(convert_type, 1)
        required_amount = amount * rate

        if data["credits"][src_type] < required_amount:
            return jsonify({"error": f"{src_type}积分不足，需要{required_amount}个"}), 400

        data["credits"][src_type] -= required_amount
        data["credits"][dest_type] += amount

        if safe_save_data(data):
            return jsonify({"message": f"成功将{required_amount}个{src_type}积分转换为{amount}个{dest_type}积分"})
        else:
            return jsonify({"error": "保存数据失败"}), 500
    else:
        return jsonify({"error": "转换类型无效"}), 400

# 获取转换比率 (to be deprecated)
@app.route('/api/credits/conversion-rates', methods=['GET'])
def get_conversion_rates():
    """获取转换比率"""
    data = load_data()
    return jsonify(data["conversion_rates"])

# 更新转换比率 (to be deprecated)
@app.route('/api/credits/conversion-rates', methods=['PUT'])
def update_conversion_rates():
    """更新转换比率"""
    data = load_data()
    rates = request.json.get('rates')

    for convert_type, rate in rates.items():
        try:
            rate_int = int(rate)
            if rate_int <= 0:
                return jsonify({"error": f"{convert_type}的比率必须大于0"}), 400
            data["conversion_rates"][convert_type] = rate_int
        except ValueError:
            return jsonify({"error": f"请输入有效的数字作为{convert_type}的比率"}), 400

    if safe_save_data(data):
        return jsonify({"message": "转换比率设置已保存"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/items', methods=['GET'])
def get_items():
    """获取道具列表"""
    data = load_data()
    return jsonify(data["items"])


@app.route('/api/items', methods=['POST'])
def add_item():
    """添加新道具"""
    data = load_data()
    item_data = request.json
    if "icon" not in item_data:
        item_data["icon"] = ""

    item_name = item_data.get('name')
    if item_name in data["items"]:
        return jsonify({"error": "道具名称已存在"}), 400

    data["items"][item_name] = {
        "id": item_data.get('id'),
        "description": item_data.get('description'),
        "category": item_data.get('category'),
        "price": item_data.get('price'),
        "icon": item_data.get('icon'),
        "parallelWorld": item_data.get('parallelWorld'),
        "recipes": item_data.get('recipes', []),  # 添加配方数据
        "gmCommand": item_data.get('gmCommand', ''),  # 添加GM命令字段
        "lootBoxes": item_data.get('lootBoxes', [])
    }

    data["backpack"][item_name] = 0

    if safe_save_data(data):
        return jsonify({"message": f"道具{item_name}添加成功"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/items/<item_name>', methods=['PUT'])
def update_item(item_name):
    """更新道具"""
    data = load_data()
    item_data = request.json
    if "icon" not in item_data:
        item_data["icon"] = ""

    if item_name not in data["items"]:
        return jsonify({"error": "找不到指定的道具"}), 404

    data["items"][item_name] = {
        "id": item_data.get('id'),
        "description": item_data.get('description'),
        "category": item_data.get('category'),
        "price": item_data.get('price'),
        "icon": item_data.get('icon'),
        "parallelWorld": item_data.get('parallelWorld'),
        "recipes": item_data.get('recipes', []),  # 添加配方数据
        "gmCommand": item_data.get('gmCommand', ''),  # 添加GM命令字段
        "lootBoxes": item_data.get('lootBoxes', [])
    }

    if safe_save_data(data):
        return jsonify({"message": f"道具{item_name}更新成功"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/items/<item_name>', methods=['DELETE'])
def delete_item(item_name):
    """删除道具"""
    data = load_data()

    if item_name in data["items"]:
        del data["items"][item_name]

    if item_name in data["backpack"]:
        del data["backpack"][item_name]

    if safe_save_data(data):
        return jsonify({"message": f"道具{item_name}已删除"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/items/batch-delete', methods=['POST'])
def batch_delete_items():
    """批量删除道具"""
    try:
        data = load_data()
        request_data = request.json
        item_names = request_data.get('item_names', [])

        if not isinstance(item_names, list):
            return jsonify({"error": "item_names必须是一个列表"}), 400

        deleted_count = 0
        not_found_items = []

        # 批量删除道具
        for item_name in item_names:
            if item_name in data["items"]:
                # 从items中删除
                del data["items"][item_name]
                # 从backpack中删除
                if item_name in data["backpack"]:
                    del data["backpack"][item_name]
                deleted_count += 1
            else:
                not_found_items.append(item_name)

        # 保存更新后的数据
        if safe_save_data(data,enable_single_field_max_check=False):
            result = {
                "message": f"成功删除{deleted_count}个道具",
                "deleted_count": deleted_count
            }

            if not_found_items:
                result["not_found_items"] = not_found_items
                result["warning"] = f"以下{len(not_found_items)}个道具未找到: {', '.join(not_found_items)}"

            return jsonify(result)
        else:
            return jsonify({"error": "保存数据失败"}), 500

    except Exception as e:
        print(f"批量删除道具时发生错误: {str(e)}")
        return jsonify({"error": f"服务器内部错误: {str(e)}"}), 500

@app.route('/api/items/buy', methods=['POST'])
def buy_item():
    """购买道具"""
    data = load_data()
    item_name = request.json.get('item_name')
    count = request.json.get('count')

    if item_name not in data["items"]:
        return jsonify({"error": "道具不存在"}), 404

    item_info = data["items"][item_name]

    # 检查积分是否足够
    for ctype, price in item_info["price"].items():
        required = price * count
        if data["credits"][ctype] < required:
            return jsonify({"error": f"{ctype}积分不足"}), 400

    # 扣除积分
    for ctype, price in item_info["price"].items():
        data["credits"][ctype] -= price * count

    # 添加到包裹
    data["backpack"][item_name] += count

    if safe_save_data(data):
        return jsonify({"message": f"成功兑换{count}个{item_name}"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/backpack', methods=['GET'])
def get_backpack():
    """获取包裹数据"""
    data = load_data()
    # 只返回拥有数量大于0的道具
    backpack = {k: v for k, v in data["backpack"].items() if v > 0}
    return jsonify(backpack)


@app.route('/api/backpack/use', methods=['POST'])
def use_item():
    """使用道具"""
    settings = load_settings()
    data = load_data()
    item_name = request.json.get('item_name')
    count = request.json.get('count')

    if count <= 0:
        return jsonify({"error": "使用数量必须大于0"}), 400

    if count > data["backpack"][item_name]:
        return jsonify({"error": "使用数量不能超过拥有数量"}), 400

    # 检查是否为宝箱道具
    item_info = data["items"][item_name]
    loot_boxes = item_info.get("lootBoxes", [])

    print('using item: ', item_info.get("category"))

    # 如果有宝箱效果，则执行开箱逻辑
    if loot_boxes and len(loot_boxes) > 0:
        import random

        # 存储开箱结果
        reward_items = []

        # 初始化连续未掉落计数器（存储在用户数据中）
        if "lootbox_miss_counts" not in data:
            data["lootbox_miss_counts"] = {}

        # 为当前宝箱创建计数器键
        miss_count_key = f"{item_name}_miss_counts"
        if miss_count_key not in data["lootbox_miss_counts"]:
            data["lootbox_miss_counts"][miss_count_key] = {}

        # 检查并删除lootbox_miss_counts中多余的items
        lbs=[]
        for lb in loot_boxes:
            for lb_dict in lb:
                lbs.append(lb_dict["itemName"])
        miss_dict=data["lootbox_miss_counts"][miss_count_key]
        lb_miss_items=list(miss_dict.keys())
        changed_items=list(set(lb_miss_items)-set(lbs))
        for i in changed_items:
            if i != "__EMPTY__":
                # print(f'deleting {miss_count_key}-{i}')
                del data["lootbox_miss_counts"][miss_count_key][i]


        # 执行指定次数的开箱
        for box_index in range(count):
            # 遍历所有开箱效果
            for loot_box_effect in loot_boxes:
                # 生成随机数用于判定掉落
                rand_value = random.random()  # 生成0-1之间的随机数
                cumulative_rate = 0.0

                # 创建当前开箱的动态掉率列表
                dynamic_rates = []
                total_base_rate = sum(item.get("dropRate", 0.0) for item in loot_box_effect)
                empty_rate = max(0.0, 1.0 - total_base_rate)  # 原始空奖励概率
                total_dynamic_rate = 0.0

                # 计算每个道具的动态掉率
                for drop_item in loot_box_effect:
                    item_key = drop_item["itemName"]
                    base_rate = drop_item.get("dropRate", 0.0)

                    # 获取连续未掉落次数
                    miss_count = data["lootbox_miss_counts"][miss_count_key].get(item_key, 0)

                    # 按公式计算动态掉率: base_rate * (1 + 0.01 * n^2)
                    dynamic_rate = base_rate * (1 + 0.01 * miss_count * miss_count)
                    dynamic_rates.append({
                        "itemName": item_key,
                        "count": drop_item["count"],
                        "baseRate": base_rate,
                        "dynamicRate": dynamic_rate,
                        "missCount": miss_count
                    })
                    total_dynamic_rate += dynamic_rate

                # 计算缩放因子以保持空奖励概率不变
                if total_dynamic_rate > 0:
                    scaling_factor = min(1.0, (1.0 - empty_rate) / total_dynamic_rate)
                else:
                    scaling_factor = 1.0

                # 归一化处理，确保总概率为1
                normalized_rates = []
                for item in dynamic_rates:
                    normalized_rate = item["dynamicRate"] * scaling_factor
                    normalized_rates.append({
                        "itemName": item["itemName"],
                        "count": item["count"],
                        "baseRate": item["baseRate"],
                        "dynamicRate": normalized_rate,
                        "missCount": item["missCount"]
                    })

                # 添加空奖励项（保持原始概率）
                if empty_rate > 0:
                    normalized_rates.append({
                        "itemName": "__EMPTY__",
                        "count": 0,
                        "baseRate": empty_rate,
                        "dynamicRate": empty_rate,
                        "missCount": 0
                    })

                # 重新计算累计概率并选择道具
                cumulative_rate = 0.0
                selected_item = None

                for drop_item in normalized_rates:
                    cumulative_rate += drop_item["dynamicRate"]

                    # 如果随机数小于等于累计概率，则获得该道具
                    if rand_value <= cumulative_rate:
                        selected_item = drop_item
                        break

                # 如果选中了道具
                if selected_item:
                    reward_item_name = selected_item["itemName"]
                    reward_item_count = selected_item["count"]

                    # 添加到奖励列表
                    reward_items.append({
                        "itemName": reward_item_name,
                        "count": reward_item_count,
                        "dropRate": selected_item["dynamicRate"],
                        "baseRate": selected_item["baseRate"],
                        "missCount": selected_item["missCount"]
                    })

                    # 添加到背包
                    if reward_item_name in data["backpack"]:
                        data["backpack"][reward_item_name] += reward_item_count
                    else:
                        data["backpack"][reward_item_name] = reward_item_count

                    # 重置该道具的连续未掉落次数
                    data["lootbox_miss_counts"][miss_count_key][reward_item_name] = 0
                else:
                    # 没有获得任何道具（空奖励）
                    pass

                # 增加未掉落道具的连续未掉落次数
                for drop_item in normalized_rates:
                    if not selected_item or drop_item["itemName"] != selected_item["itemName"]:
                        item_key = drop_item["itemName"]
                        current_miss_count = data["lootbox_miss_counts"][miss_count_key].get(item_key, 0)
                        data["lootbox_miss_counts"][miss_count_key][item_key] = current_miss_count + 1
                        # print(f"{item_key}连续未掉落次数: {current_miss_count}")

        # 减少包裹中的道具数量
        data["backpack"][item_name] -= count

        # 添加到使用日志
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        item_summary = {}
        for item in reward_items:
            itm_name = item['itemName']
            if itm_name != "__EMPTY__":
                if itm_name in item_summary:
                    item_summary[itm_name] += item['count']
                else:
                    item_summary[itm_name] = item['count']
        log_message = f"开箱获得: " + ", ".join([f"{name}x{count}" for name, count in item_summary.items()])
        # log_message = f"开箱获得: " + ", ".join([f"{item['itemName']}x{item['count']}" for item in reward_items])
        # data["use_logs"].append((current_time, item_name, count, log_message))

        if safe_save_data(data):
            return jsonify({
                "message": log_message,#f"成功开启{count}个{item_name}",
                "reward_items": reward_items
            })
        else:
            return jsonify({"error": "保存数据失败"}), 500
    elif "实物" in item_info.get("category"):
        data["backpack"][item_name] -= count
        if safe_save_data(data):
            return jsonify({"message": f"恭喜获得{item_name}", "description": f"{item_info.get('description')}"})
        else:
            return jsonify({"error": "保存数据失败"}), 500
        # print(f"恭喜获得{item_name}")
        # return jsonify({"error": f"恭喜获得{item_name}"}), 400
    else:
        # 原有的GM命令逻辑
        gmcmd_template = item_info.get("gmCommand", "")

        if len(gmcmd_template) <= 1:
            return jsonify({"error": "缺少GM命令，无法使用"}), 400

        keywords = ['count', '数量', '个数', '数目', 'cnt', 'num']

        # 创建一个正则表达式模式，匹配包含关键词的尖括号内容
        def replace_keyword_placeholders(text, keywords, replacement):
            # 转义关键词以防止特殊字符影响正则表达式
            escaped_keywords = [re.escape(keyword) for keyword in keywords]
            # 构建正则表达式：匹配以<开头、以>结尾，中间包含任一关键词的内容
            pattern = f"<.*?(?:{'|'.join(escaped_keywords)}).*?>"
            return re.sub(pattern, str(replacement), text, count=1)

        gm_command = replace_keyword_placeholders(gmcmd_template, keywords, count)

        # 减少包裹中的道具数量
        data["backpack"][item_name] -= count

        # # 添加到使用日志
        # current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        # data["use_logs"].append((current_time, item_name, count, gm_command))

        if safe_save_data(data):
            return jsonify({
                "message": f"已使用{count}个{item_name}",
                "gm_command": gm_command
            })
        else:
            return jsonify({"error": "保存数据失败"}), 500
# def use_item():
#     """使用道具"""
#     settings = load_settings()
#     data = load_data()
#     item_name = request.json.get('item_name')
#     count = request.json.get('count')
#
#     if count <= 0:
#         return jsonify({"error": "使用数量必须大于0"}), 400
#
#     if count > data["backpack"][item_name]:
#         return jsonify({"error": "使用数量不能超过拥有数量"}), 400
#
#     # 检查是否为宝箱道具
#     item_info = data["items"][item_name]
#     loot_boxes = item_info.get("lootBoxes", [])
#
#     # 如果有宝箱效果，则执行开箱逻辑
#     if loot_boxes and len(loot_boxes) > 0:
#         import random
#
#         # 存储开箱结果
#         reward_items = []
#
#         # 执行指定次数的开箱
#         for _ in range(count):
#             # 遍历所有开箱效果
#             for loot_box_effect in loot_boxes:
#                 # 生成随机数用于判定掉落
#                 rand_value = random.random()  # 生成0-1之间的随机数
#                 cumulative_rate = 0.0
#
#                 # 遍历该效果中的所有可能掉落项
#                 for drop_item in loot_box_effect:
#                     cumulative_rate += drop_item.get("dropRate", 0.0)
#
#                     # 如果随机数小于等于累计概率，则获得该道具
#                     if rand_value <= cumulative_rate:
#                         reward_item_name = drop_item["itemName"]
#                         reward_item_count = drop_item["count"]
#
#                         # 添加到奖励列表
#                         reward_items.append({
#                             "itemName": reward_item_name,
#                             "count": reward_item_count
#                         })
#
#                         # 添加到背包
#                         if reward_item_name in data["backpack"]:
#                             data["backpack"][reward_item_name] += reward_item_count
#                         else:
#                             data["backpack"][reward_item_name] = reward_item_count
#                         break
#
#         # 减少包裹中的道具数量
#         data["backpack"][item_name] -= count
#
#         # 添加到使用日志
#         current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#         log_message = f"开箱获得: " + ", ".join([f"{item['itemName']}x{item['count']}" for item in reward_items])
#         data["use_logs"].append((current_time, item_name, count, log_message))
#
#         if safe_save_data(data):
#             return jsonify({
#                 "message": f"成功开启{count}个{item_name}",
#                 "reward_items": reward_items
#             })
#         else:
#             return jsonify({"error": "保存数据失败"}), 500
#     else:
#         # 原有的GM命令逻辑
#         gmcmd_template = item_info.get("gmCommand", "")
#         if len(gmcmd_template) <= 1:
#             return jsonify({"error": "缺少GM命令，无法使用"}), 400
#
#         keywords = ['count', '数量', '个数', '数目', 'cnt', 'num']
#
#         # 创建一个正则表达式模式，匹配包含关键词的尖括号内容
#         def replace_keyword_placeholders(text, keywords, replacement):
#             # 转义关键词以防止特殊字符影响正则表达式
#             escaped_keywords = [re.escape(keyword) for keyword in keywords]
#             # 构建正则表达式：匹配以<开头、以>结尾，中间包含任一关键词的内容
#             pattern = f"<.*?(?:{'|'.join(escaped_keywords)}).*?>"
#             return re.sub(pattern, str(replacement), text, count=1)
#
#         gm_command = replace_keyword_placeholders(gmcmd_template, keywords, count)
#
#         # 减少包裹中的道具数量
#         data["backpack"][item_name] -= count
#
#         # 添加到使用日志
#         current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#         data["use_logs"].append((current_time, item_name, count, gm_command))
#
#         if safe_save_data(data):
#             return jsonify({
#                 "message": f"成功使用{count}个{item_name}",
#                 "gm_command": gm_command
#             })
#         else:
#             return jsonify({"error": "保存数据失败"}), 500
# def use_item():
#     """使用道具"""
#     settings = load_settings()
#     data = load_data()
#     item_name = request.json.get('item_name')
#     count = request.json.get('count')
#
#     if count <= 0:
#         return jsonify({"error": "使用数量必须大于0"}), 400
#
#     if count > data["backpack"][item_name]:
#         return jsonify({"error": "使用数量不能超过拥有数量"}), 400
#
#
#     # 生成GM命令
#     item_info = data["items"][item_name]
#     gmcmd_template = item_info.get("gmCommand", "") #list(settings['gmCommands'].values())[0].get('gmCommand', ''))
#     if len(gmcmd_template)<=1:
#         return jsonify({"error": "缺少GM命令，无法使用"}), 400
#
#
#
#     keywords = ['count', '数量', '个数', '数目', 'cnt', 'num']  # 可以根据需要添加更多关键词
#     # 创建一个正则表达式模式，匹配包含关键词的尖括号内容
#     def replace_keyword_placeholders(text, keywords, replacement):
#         # 转义关键词以防止特殊字符影响正则表达式
#         escaped_keywords = [re.escape(keyword) for keyword in keywords]
#         # 构建正则表达式：匹配以<开头、以>结尾，中间包含任一关键词的内容
#         pattern = f"<.*?(?:{'|'.join(escaped_keywords)}).*?>"
#         return re.sub(pattern, str(replacement), text, count=1)
#
#     gm_command = replace_keyword_placeholders(gmcmd_template, keywords, count)
#
#     # if item_name == "经验书" or item_name == "超级经验书":
#     #     gm_command = f"d_c2scmd 10889 {item_info['id']}"
#     # else:
#     #     gm_command = f"d_c2scmd 10800 {item_info['id']} {count}"
#
#     # 减少包裹中的道具数量
#     data["backpack"][item_name] -= count
#
#     # 添加到使用日志
#     current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#     data["use_logs"].append((current_time, item_name, count, gm_command))
#
#     if safe_save_data(data):
#         return jsonify({
#             "message": f"成功使用{count}个{item_name}",
#             "gm_command": gm_command
#         })
#     else:
#         return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/logs_old', methods=['GET'])
def get_logs_old():
    """获取日志"""
    try:
        if os.path.exists(config_manager.LOGS_FILE):
            with open(config_manager.LOGS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return jsonify({'logs': data.get('logs', [])})
        else:
            return jsonify({'logs': []})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/save_old', methods=['POST'])
def save_logs_old():
    """保存日志"""
    try:
        data = request.json
        with open(config_manager.LOGS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return jsonify({'message': '日志保存成功'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/clear', methods=['POST'])
@token_required()
def clear_logs():
    """清空日志"""
    try:
        if os.path.exists(config_manager.LOGS_FILE):
            os.remove(config_manager.LOGS_FILE)
        return jsonify({'message': '日志已清空'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


# @app.route('/api/logs', methods=['GET'])
# def get_logs():
#     """获取使用日志"""
#     data = load_data()
#     return jsonify(data["use_logs"])
#
#
# @app.route('/api/logs/clear', methods=['POST'])
# def clear_logs():
#     """清空日志"""
#     data = load_data()
#     data["use_logs"] = []
#
#     if safe_save_data(data):
#         return jsonify({"message": "日志已清空"})
#     else:
#         return jsonify({"error": "保存数据失败"}), 500


@app.route('/api/tasks', methods=['GET'])
def get_tasks():
    """获取任务列表"""
    data = load_data()
    # 确保所有任务都有必要的字段（兼容旧数据）
    for task in data["tasks"]:
        if "task_type" not in task:
            task["task_type"] = "无循环"
        if "completed_count" not in task:
            task["completed_count"] = 0
        if "max_completions" not in task:
            task["max_completions"] = 0
    return jsonify(data["tasks"])

def tailor_task_name(task_name):
    """若任务名称过长则裁剪任务名称"""
    settings = load_settings()
    try:
        max_length = settings.taskNameMaxLength
    except:
        max_length = 250

    return task_name[:max_length]+"..." if len(task_name) > max_length else task_name


@app.route('/api/tasks', methods=['POST'])
def add_task():
    """添加新任务"""
    data = load_data()
    task_data = request.json

    # 生成新的任务ID
    all_ids = [task["id"] for task in data["tasks"]]
    existing_id = task_data.get('id')
    if existing_id and existing_id not in all_ids:
        new_id = task_data.get('id')
    else:
        new_id = max([task["id"] for task in data["tasks"]], default=0) + 1


    new_task = {
        "id": new_id,
        "name": tailor_task_name(task_data.get('name')),
        "description": task_data.get('description'),
        "task_type": task_data.get('task_type', '无循环'),
        "max_completions": task_data.get('max_completions', 0),
        "category": task_data.get('category', '未分类'),
        "domain": task_data.get('domain', '学习'),
        "priority": task_data.get('priority', '重要且紧急'),
        "completed_count": 0,
        "status": task_data.get('status', '未完成'),
        "start_time": task_data.get('start_time'),
        "complete_time": task_data.get('complete_time'),
        "archived": task_data.get('archived', False),
        "total_completion_count": task_data.get('total_completion_count', 0),
        "credits_reward": task_data.get('credits_reward', {}),
        "items_reward": task_data.get('items_reward', {}),
        "exp_reward": task_data.get('exp_reward', 0),
        "notes": task_data.get('notes', ''),
        "tags": task_data.get('tags', []),
    }

    data["tasks"].append(new_task)

    if safe_save_data(data):
        return jsonify({"message": f"任务'{new_task['name']}'添加成功", "task": new_task})
    else:
        return jsonify({"error": "保存数据失败"}), 500

@app.route('/api/tasks/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    """更新任务"""
    data = load_data()
    task_data = request.json

    for task in data["tasks"]:
        if task["id"] == task_id:
            task["name"] = tailor_task_name(task_data.get('name'))
            task["description"] = task_data.get('description')
            task["task_type"] = task_data.get('task_type', '无循环')
            task["max_completions"] = task_data.get('max_completions', 0)
            task["category"] = task_data.get('category', '未分类')
            task["domain"] = task_data.get('domain', '学习')  # 更新领域属性
            task["priority"] = task_data.get('priority', '重要且紧急')  # 更新重要性属性
            task["credits_reward"] = task_data.get('credits_reward', {})
            task["items_reward"] = task_data.get('items_reward', {})
            # 添加新增字段的处理
            task["start_time"] = task_data.get('start_time')
            task["complete_time"] = task_data.get('complete_time')
            task["archived"] = task_data.get('archived', False)
            task['status'] = task_data.get('status', '未完成')
            task['completed_count'] = task_data.get('completed_count', 0)
            task["total_completion_count"] = task_data.get('total_completion_count', 0)
            exp_reward=task_data.get('exp_reward', 0)
            task["exp_reward"] = exp_reward
            task["notes"] = task_data.get('notes', '')
            task["tags"] = task_data.get('tags', [])
            # print(f"设置任务 {task_id} 的经验值为: {exp_reward}")


            if safe_save_data(data):
                return jsonify({"message": f"任务'{task['name']}'更新成功", "task": task})
            else:
                return jsonify({"error": "保存数据失败"}), 500

    return jsonify({"error": "任务不存在"}), 404


@app.route('/api/tasks/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    """删除任务"""
    data = load_data()
    data["tasks"] = [task for task in data["tasks"] if task["id"] != task_id]

    if safe_save_data(data):
        return jsonify({"message": "任务已删除"})
    else:
        return jsonify({"error": "保存数据失败"}), 500


def check_level_up(data):
    """检查并处理角色升级"""
    settings = load_settings()
    if not settings or "expFormulas" not in settings:
        return None

    exp_formulas = settings["expFormulas"]
    current_exp = data["stats"]["exp"]
    current_level = data["stats"]["level"]

    # 获取公式参数 a 和 n
    a = exp_formulas.get("levelUpA", 100)
    n = exp_formulas.get("levelUpN", 2.5)

    # 使用与前端一致的等级计算公式
    calculated_level = int((current_exp / a) ** (1/n)) + 1 if current_exp > 0 else 1

    # 检查是否达到升级条件
    if calculated_level > current_level:
        # 升级到计算出的新等级
        level_gain = calculated_level - current_level
        data["stats"]["level"] = calculated_level
        # 保持现有经验值，让前端正确显示进度条
        return f"升级到 {calculated_level} 级!" if level_gain == 1 else f"升级 {level_gain} 级到 {calculated_level} 级!"

    return None

@app.route('/api/tasks/<int:task_id>/complete', methods=['POST'])
def complete_task(task_id):
    """完成任务并发放奖励"""
    data = load_data()
    new_data = request.json

    # 查找目标任务
    task = next((t for t in data["tasks"] if t["id"] == task_id), None)
    if not task:
        return jsonify({"error": "任务不存在"}), 404

    # 使用前端传入的状态、完成时间、完成次数、总完成次数（如果存在）
    if 'status' in new_data:
        task["status"] = new_data['status']

    if 'complete_time' in new_data:
        task["complete_time"] = new_data['complete_time']
    elif not task["complete_time"]:
        # 完成时间若不存在则补全
        task["complete_time"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if 'completed_count' in new_data:
        task["completed_count"] = new_data['completed_count']

    if 'total_completion_count' in new_data:
        task["total_completion_count"] = new_data['total_completion_count']

    # 发放奖励
    reward_info = []

    # 发放经验奖励
    if task.get("exp_reward", 0) > 0:
        exp_reward = task['exp_reward']
        data["stats"]["exp"] += exp_reward
        reward_info.append(f"经验奖励: {exp_reward}")

        # 检查是否升级
        level_up_info = check_level_up(data)
        if level_up_info:
            reward_info.append(level_up_info)

    # 发放积分奖励
    if task.get("credits_reward"):
        for credit_type, amount in task["credits_reward"].items():
            if credit_type in data["credits"] and amount > 0:
                data["credits"][credit_type] += amount
                reward_info.append(f"{credit_type}: {amount}")

                # 根据积分类型更新对应属性
                settings = load_settings()
                if settings and "characterSettings" in settings:
                    for setting in settings["characterSettings"]:
                        if setting.get("creditType") == credit_type and "propertyCategory" in setting:
                            property_category = setting["propertyCategory"]
                            if property_category in data["properties"]:
                                data["properties"][property_category] += amount
                                break

    # 发放道具奖励
    if task.get("items_reward"):
        for item_name, count in task["items_reward"].items():
            if item_name in data["backpack"]:
                data["backpack"][item_name] += count
            else:
                data["backpack"][item_name] = count
        reward_info.append("道具奖励: " + ", ".join([f"{k}x{v}" for k, v in task["items_reward"].items()]))

    if safe_save_data(data):
        return jsonify({
            "message": f"任务'{task['name']}'已完成",
            "reward": "\n".join(reward_info) if reward_info else "无奖励"
        })
    else:
        return jsonify({"error": "保存数据失败"}), 500

@app.route('/api/tasks/<int:task_id>/complete_old', methods=['POST'])
def complete_task_old(task_id):
    """完成任务并发放奖励"""
    data = load_data()
    new_data = request.json

    # 查找目标任务
    task = next((t for t in data["tasks"] if t["id"] == task_id), None)
    if not task:
        return jsonify({"error": "任务不存在"}), 404

    # 检查是否可以完成任务
    # if task["task_type"] == "无循环" and task["completed_count"] > 0:
    #     return jsonify({"error": "无循环任务已完成，无法重复完成"}), 400
    # 使用前端传入的状态、完成时间、完成次数、总完成次数（如果存在）
    if 'status' in new_data:
        task["status"] = new_data['status']
        # print("设置任务状态为：",task["status"])
    if 'complete_time' in new_data:
        task["complete_time"] = new_data['complete_time']
        #print("设置任务完成时间为：",task["complete_time"])
    elif not task["complete_time"]:
        # 完成时间若不存在则补全
        task["complete_time"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        #print("设置任务完成时间为：",task["complete_time"])
    if 'completed_count' in new_data:
        task["completed_count"] = new_data['completed_count']
        #print("设置任务完成次数为：",task["completed_count"])
    if 'total_completion_count' in new_data:
        task["total_completion_count"] = new_data['total_completion_count']
        #print("设置任务总完成次数为：",task["total_completion_count"])

    # 发放奖励
    reward_info = []

    # 发放奖励(若请求数据中没有items_reward项则可能是完成次数溢出的情况，不予奖励）
    if 'items_reward' in new_data:
        #print('items_reward distributing...')
        if task.get("exp_reward", 0) > 0:
            reward_info.append(f"经验奖励: {task['exp_reward']}")
        # 发放属性奖励
        if task.get("properties_reward"):
            reward_info.append("属性奖励: " + ", ".join([f"{k}{v}" for k, v in task["properties_reward"].items()]))
        # 发放积分奖励
        if task.get("credits_reward"):
            reward_info.append("积分奖励: " + ", ".join([f"{k}{v}" for k, v in task["credits_reward"].items()]))
        # 发放道具奖励
        if task.get("items_reward"):
            for item_name, count in task["items_reward"].items():
                #print(f"发放道具奖励: {item_name}x{count}")
                if item_name in data["backpack"]:
                    #print(f"{item_name}已存在背包中，数量增加: {count}")
                    data["backpack"][item_name] += count
                else:
                    #print(f"添加道具奖励: {item_name}x{count}")
                    data["backpack"][item_name] = count
            reward_info.append("道具奖励: " + ", ".join([f"{k}x{v}" for k, v in task["items_reward"].items()]))


    if safe_save_data(data):
        return jsonify({
            "message": f"任务'{task['name']}'已完成\n",
            "reward": "\n".join(reward_info) if reward_info else "无奖励"
        })
    else:
        return jsonify({"error": "保存数据失败"}), 500

    return jsonify({"error": "任务不存在"}), 404

@app.route('/api/tasks/<int:task_id>/update_status_completed', methods=['POST'])
def update_as_completed(task_id):
    """完成任务并发放奖励"""
    data = load_data()
    new_data = request.json

    # 查找目标任务
    task = next((t for t in data["tasks"] if t["id"] == task_id), None)
    if not task:
        return jsonify({"error": "任务不存在"}), 404

    # 检查是否可以完成任务
    # if task["task_type"] == "无循环" and task["completed_count"] > 0:
    #     return jsonify({"error": "无循环任务已完成，无法重复完成"}), 400
    # 使用前端传入的状态、完成时间、完成次数、总完成次数（如果存在）
    if 'status' in new_data:
        task["status"] = new_data['status']
        # print("设置任务状态为：",task["status"])

    if safe_save_data(data):
        return jsonify({
            "message": f"任务'{task['name']}'已完成\n",
        })
    else:
        return jsonify({"error": "保存数据失败"}), 500

    return jsonify({"error": "任务不存在"}), 404


def get_field_mapping():
    """获取中英文字段名映射表"""
    return {
        # 基本字段映射
        '道具名称': 'name',
        'name': 'name',
        '名称': 'name',

        'ID': 'id',
        'id': 'id',
        '道具ID': 'id',
        '道具id': 'id',

        '描述': 'description',
        'description': 'description',

        '分类': 'category',
        '类别': 'category',
        'category': 'category',

        '图标': 'icon',
        'icon': 'icon',

        '游戏世界': 'parallelWorld',
        'parallelWorld': 'parallelWorld',
        'parallel_world': 'parallelWorld',

        'GM指令': 'gmCommand',
        'gm指令': 'gmCommand',
        'gmCommand': 'gmCommand',
        'gm_command': 'gmCommand',

        # JSON字段
        '合成配方': 'recipes',
        'recipes': 'recipes',

        '宝箱效果': 'lootBoxes',
        'lootBoxes': 'lootBoxes',
        'loot_boxes': 'lootBoxes',
    }

@app.route('/api/items/import', methods=['POST'])
def import_items():
    """从CSV文件导入道具 - 完善版"""
    try:
        # 文件上传验证
        if 'file' not in request.files:
            return jsonify({"error": "没有上传文件"}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "文件名为空"}), 400

        if not file.filename.endswith('.csv'):
            return jsonify({"error": "只支持CSV格式文件"}), 400

        # 读取文件内容
        content = file.read().decode('utf-8-sig')  # 使用 utf-8-sig 处理 BOM
        # print(f"接收到CSV文件内容: {content}")

        # 使用标准库 csv 模块解析CSV
        csv_reader = csv.reader(io.StringIO(content))
        lines = list(csv_reader)

        if len(lines) < 2:
            return jsonify({"error": "CSV文件内容过少，至少需要包含表头和一行数据"}), 400

        # 解析并转换表头
        raw_headers = [h.strip() for h in lines[0]]
        field_mapping = get_field_mapping()
        headers = [field_mapping.get(header, header) for header in raw_headers]
        # print(f"原始表头: {raw_headers}")
        # print(f"转换后表头: {headers}")

        # 验证必需字段
        required_fields = ['name', 'description']
        missing_fields = [field for field in required_fields if field not in headers]
        if missing_fields:
            return jsonify({"error": f"缺少必需字段: {missing_fields}"}), 400

        # 获取积分类型列表，用于识别价格字段
        settings = load_settings()
        credit_types = settings.get("creditTypes", ["水晶", "星钻", "魂玉", "骨贝", "源石", "灵石", "金币", "元宝"])

        # 解析数据行
        data = load_data()
        imported_count = 0
        failed_count = 0
        errors = []
        added_count = 0
        updated_count = 0

        for i, row in enumerate(lines[1:], 1):  # 从第二行开始
            if not any(cell.strip() for cell in row):  # 跳过空行
                continue

            # print(f"正在处理第{i}行数据: {row}")
            try:
                # 创建道具数据
                item_data = {}

                # 处理所有字段
                for j, header in enumerate(headers):
                    if j < len(row):
                        value = row[j].strip()
                        item_data[header] = value

                # # 特殊处理ID字段
                # if 'id' in item_data:
                #     try:
                #         item_data['id'] = int(float(item_data['id'])) if item_data['id'] else 0
                #     except ValueError:
                #         item_data['id'] = 0

                # 处理JSON字段 (增强版)
                json_fields = ['recipes', 'lootBoxes']
                for field in json_fields:
                    if field in item_data and item_data[field]:
                        try:
                            # 获取原始值
                            json_string = item_data[field]

                            # 尝试修复JSON格式问题
                            fixed_json_string = fix_json_format(json_string)

                            # 尝试解析为JSON
                            parsed_value = json.loads(fixed_json_string) if fixed_json_string else []

                            # 验证解析结果是否为列表
                            if isinstance(parsed_value, list):
                                item_data[field] = parsed_value
                            else:
                                item_data[field] = []
                        except Exception as e:
                            print(f"JSON处理错误 {field}: {str(e)}, 原始值: {item_data[field]}")
                            item_data[field] = []
                    else:
                        item_data[field] = []

                # 处理price字段
                item_data['price'] = {}

                # 设置默认值
                if 'category' not in item_data or not item_data['category']:
                    item_data['category'] = '未分类'

                if 'description' not in item_data:
                    item_data['description'] = ''

                if 'icon' not in item_data:
                    item_data['icon'] = ''

                if 'parallelWorld' not in item_data:
                    item_data['parallelWorld'] = '默认世界'

                if 'gmCommand' not in item_data:
                    item_data['gmCommand'] = ''
                # 处理积分价格字段（在最后处理，避免覆盖）
                for header in headers:
                    if header in credit_types:
                        try:
                            price_value = float(item_data[header]) if item_data[header] else 0
                            if price_value > 0:
                                item_data['price'][header] = round(price_value, 2)
                        except ValueError:
                            pass
                # 验证必需字段
                # if not item_data.get('name') or not item_data.get('id'):
                if not item_data.get('name'):
                    errors.append(f"第{i}行: 道具名称为空")
                    failed_count += 1
                    continue

                # 检查ID是否已存在
                item_name = item_data['name']
                # item_id = item_data['id']
                # print(f"3正在处理道具: {item_data}")

                # 检查是否已存在同名或同ID的道具
                item_exists = False
                existing_item_name = None
                for name, existing_item in data['items'].items():
                    if name == item_name:
                    # if name == item_name or existing_item.get('id') == item_id:
                        item_exists = True
                        existing_item_name = name
                        break
                # print(f"4正在处理道具: {item_data}")

                if item_exists:
                    # 更新现有道具
                    # print(f"5正在处理道具: {existing_item_name} ")
                    old_item = data['items'][existing_item_name].copy()
                    data['items'][existing_item_name].update(item_data)
                    # print(f"6更新道具: {data['items'][existing_item_name]} ")
                    # print(f"更新道具: {item_name}")
                    updated_count += 1

                    # 如果道具名称改变，需要更新背包
                    if existing_item_name != item_name:
                        # 转移背包数量
                        if existing_item_name in data['backpack']:
                            data['backpack'][item_name] = data['backpack'].pop(existing_item_name, 0)
                        else:
                            data['backpack'][item_name] = 0
                else:
                    # 添加新道具
                    data['items'][item_name] = item_data
                    data['backpack'][item_name] = 0  # 初始化背包数量
                    # print(f"新增道具: {item_name}")
                    added_count += 1

                imported_count += 1

            except Exception as e:
                errors.append(f"第{i}行解析错误: {str(e)}")
                failed_count += 1
                continue

        # 保存数据
        if safe_save_data(data,enable_single_field_max_check=False):
            message = f"成功导入{imported_count}个道具"
            if added_count > 0:
                message += f"，新增{added_count}个"
            if updated_count > 0:
                message += f"，更新{updated_count}个"
            if failed_count > 0:
                message += f"，失败{failed_count}个"

            return jsonify({
                "message": message,
                "importedCount": imported_count,
                "addedCount": added_count,
                "updatedCount": updated_count,
                "failedCount": failed_count,
                "errors": errors
            })
        else:
            return jsonify({"error": "保存数据失败"}), 500

    except Exception as e:
        print(f"导入道具时发生错误: {str(e)}")
        return jsonify({"error": f"导入失败: {str(e)}"}), 500


def fix_json_format(json_string):
    """修复JSON格式问题"""
    if not json_string:
        return json_string

    try:
        # 如果已经是有效的JSON，直接返回
        json.loads(json_string)
        return json_string
    except json.JSONDecodeError:
        pass

    # 尝试修复格式
    fixed = json_string.strip()

    # 如果被引号包围，去掉外层引号
    if fixed.startswith('"') and fixed.endswith('"'):
        fixed = fixed[1:-1]

    # 替换双重转义的引号
    fixed = fixed.replace('""', '"')

    # 修复键名缺少引号的问题
    import re

    # 修复对象开始后的键 {key: -> {"key":
    fixed = re.sub(r'\{([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r'{"\1":', fixed)
    # 修复逗号后的键 ,key: -> ,"key":
    fixed = re.sub(r',\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r',"\1":', fixed)
    # 修复数组中的对象键 [{key: -> [{"key":
    fixed = re.sub(r'\[\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r'[{"\1":', fixed)

    # 修复字符串值缺少引号的问题
    # 匹配 : 后面跟着非引号、非逗号、非大括号的字符序列，直到遇到逗号或大括号结束
    fixed = re.sub(r':\s*([a-zA-Z0-9_\u4e00-\u9fa5]+)(?=[,}])', r':"\1"', fixed)

    # 特殊处理数字值，移除数字周围的引号（如果被错误添加）
    fixed = re.sub(r':"(\d+\.?\d*)"', r':\1', fixed)

    # 修复布尔值和null值
    fixed = fixed.replace(':true', ':true').replace(':false', ':false').replace(':null', ':null')
    fixed = fixed.replace(':"true"', ':true').replace(':"false"', ':false').replace(':"null"', ':null')

    return fixed



@app.route('/api/tasks/import', methods=['POST'])
def import_tasks_from_csv():
    """从CSV文件导入任务"""
    try:
        # 获取上传的文件
        if 'file' not in request.files:
            return jsonify({"error": "没有上传文件"}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "未选择文件"}), 400

        # 读取CSV内容
        stream = file.stream.read().decode('utf-8')
        csv_data = csv.DictReader(stream.splitlines(), delimiter=',')

        data = load_data()
        added_count = 0

        # 处理CSV数据
        for row in csv_data:
            try:
                task_name = row.get('name', '').strip()
                if not task_name:
                    continue

                task = {
                    "id": len(data["tasks"]) + 1,
                    "name": task_name,
                    "description": row.get('description', '').strip(),
                    "task_type": row.get('task_type', '无循环').strip(),
                    "max_completions": int(row.get('max_completions', 0)),
                    "completed_count": 0,
                    "category": row.get('category', '未分类').strip(),
                    "domain": row.get('domain', '学习').strip(),  # 添加领域字段
                    "priority": row.get('priority', '重要且紧急').strip(),  # 添加重要性字段
                    "credits_reward": {},
                    "items_reward": {},
                    # 添加新增字段
                    "start_time": row.get('start_time'),
                    "complete_time": row.get('complete_time'),
                    "archived": row.get('archived', 'False').lower() == 'true',
                    "total_completion_count": int(row.get('total_completion_count', 0))
                }

                # 处理积分奖励
                for key, value in row.items():
                    if key.startswith('credit_') and value.strip():
                        credit_type = key.replace('credit_', '')
                        try:
                            task["credits_reward"][credit_type] = int(value.strip())
                        except ValueError:
                            pass

                # 处理道具奖励
                for key, value in row.items():
                    if key.startswith('item_') and value.strip():
                        item_name = key.replace('item_', '')
                        try:
                            task["items_reward"][item_name] = int(value.strip())
                        except ValueError:
                            pass

                data["tasks"].append(task)
                added_count += 1

            except (ValueError, KeyError) as e:
                continue

        if safe_save_data(data,enable_single_field_max_check=False):
            return jsonify({
                "message": f"成功导入{added_count}个任务",
                "imported": added_count
            })
        else:
            return jsonify({"error": "保存数据失败"}), 500

    except Exception as e:
        return jsonify({"error": f"导入失败: {str(e)}"}), 500


# def batch_archive_tasks():
#     """批量归档已完成的任务"""
#     data = load_data()
#     archived_count = 0
#     today = datetime.now().date()
#
#     for task in data["tasks"]:
#         # 检查任务是否已完成且完成时间在今天之前
#         if task.get("status") == "已完成":
#             completion_time = task.get("completion_time")
#             if completion_time:
#                 completion_date = datetime.strptime(completion_time, "%Y-%m-%d").date()
#                 if completion_date < today:
#                     task["archived"] = "是"
#                     archived_count += 1
#
#     if safe_save_data(data):
#         return jsonify({"message": f"成功归档{archived_count}个任务"})
#     else:
#         return jsonify({"error": "保存数据失败"}), 500



def batch_archive_tasks():
    """批量归档已完成的任务"""
    try:
        data = load_data()
        updated_count = 0
        today = date.today()

        # 遍历所有任务，将已完成且未归档的任务进行归档
        for task in data.get("tasks", []):
            # 检查任务是否已完成且未归档
            if (not task.get("archived", False) and
                    task.get("status") == "已完成"):

                # 检查任务完成时间是否不是今天
                complete_time_str = task.get("complete_time")
                should_archive = False

                if complete_time_str:
                    try:
                        # 解析完成时间字符串
                        if isinstance(complete_time_str, str):
                            # 处理不同的时间格式
                            if 'T' in complete_time_str:
                                complete_date = datetime.fromisoformat(complete_time_str).date()
                            elif '/' in complete_time_str:
                                complete_date = datetime.strptime(complete_time_str, "%Y/%m/%d %H:%M:%S").date()
                            elif '-' in complete_time_str and ':' in complete_time_str:
                                complete_date = datetime.strptime(complete_time_str, "%Y-%m-%d %H:%M:%S").date()
                            else:
                                # 如果无法解析，假设需要归档
                                should_archive = True
                                complete_date = None

                            if complete_date and complete_date != today:
                                should_archive = True
                        else:
                            # 如果complete_time不是字符串，假设需要归档
                            should_archive = True
                    except (ValueError, TypeError):
                        # 解析失败，假设需要归档
                        should_archive = True
                else:
                    # 没有完成时间，假设需要归档
                    should_archive = True

                if should_archive:
                    task["archived"] = True
                    updated_count += 1

        # 保存更新后的数据
        if updated_count > 0 and safe_save_data(data):
            print(f"已归档{updated_count}个任务")
            # 返回可序列化的字典而不是Response对象
            return updated_count
        else:
            return 0

    except Exception as e:
        print(f"批量归档任务时出错: {str(e)}")
        return 0  # 返回数字而不是抛出异常

@app.route('/api/items/craft', methods=['POST'])
def craft_item():
    """合成道具"""
    data = load_data()
    request_data = request.json
    item_name = request_data.get('item_name')
    recipe_index = request_data.get('recipe_index', 0)
    count = request_data.get('count', 1)

    if item_name not in data["items"]:
        return jsonify({"error": "道具不存在"}), 404

    item_info = data["items"][item_name]

    # 检查是否有配方
    if "recipes" not in item_info or not item_info["recipes"]:
        return jsonify({"error": "该道具没有合成配方"}), 400

    # 检查配方索引是否有效
    if recipe_index >= len(item_info["recipes"]):
        return jsonify({"error": "配方索引无效"}), 400

    recipe = item_info["recipes"][recipe_index]

    # 检查材料是否足够
    for material in recipe:
        material_name = material["itemName"]
        required_amount = material["count"] * count

        # 检查材料是否在包裹中存在
        if material_name not in data["backpack"]:
            return jsonify({"error": f"缺少材料: {material_name}"}), 400

        # 检查材料数量是否足够
        if data["backpack"][material_name] < required_amount:
            return jsonify({"error": f"材料 {material_name} 数量不足，需要 {required_amount} 个"}), 400

    # 扣除材料
    for material in recipe:
        material_name = material["itemName"]
        required_amount = material["count"] * count
        data["backpack"][material_name] -= required_amount

        # 如果材料数量为0，可以从背包中移除（可选）
        if data["backpack"][material_name] == 0:
            # 可以选择删除或保留，这里选择保留为0
            pass

    # 增加合成后的道具到包裹
    if item_name not in data["backpack"]:
        data["backpack"][item_name] = 0
    data["backpack"][item_name] += count

    if safe_save_data(data):
        return jsonify({
            "message": f"成功合成 {count} 个 {item_name}",
            "crafted_item": item_name,
            "crafted_count": count,
            "materials_used": recipe
        })
    else:
        return jsonify({"error": "保存数据失败"}), 500

# 添加循环周期检查函数
def check_and_update_cycle_tasks():
    """检查并重置循环任务"""
    data = load_data()
    updated_count = 0
    now = datetime.now()
    for task in data["tasks"]:
        # 检查任务是否为循环任务（非"无循环"类型）且有开始时间
        if task["task_type"] != "无循环" and task.get("start_time"):
            start_time = task["start_time"]
            # print('c1_start_time', start_time, type(start_time))
            if isinstance(task["start_time"], str):
                start_time=start_time.split(' ')[0].split('T')[0]
                if '/' in start_time:
                    start_time = datetime.strptime(start_time, "%Y/%m/%d")
                elif '-' in start_time:
                    start_time = datetime.strptime(start_time, "%Y-%m-%d")
                else:
                    start_time = datetime.strptime(start_time, "%Y%m%d")
                print('c2_task_type', start_time)

            # 判断是否需要重置任务
            should_reset = False
            new_start_time = None

            # 根据循环周期类型检查是否需要重置
            if task["task_type"] == "日循环":
                # 如果不是今天，则需要重置
                # print("无循环：", start_time.date())
                # print("今天：", now.date())
                if start_time.date() != now.date():
                    should_reset = True
                    new_start_time = datetime(now.year, now.month, now.day, 0, 0, 0)
                    # print("无循环reset：", new_start_time)
            elif task["task_type"] == "周循环":
                # 如果不在同一周，则需要重置
                # print("周循环：", start_time.isocalendar())
                # print("今周：", now.isocalendar())
                if start_time.isocalendar()[1] != now.isocalendar()[1] or start_time.year != now.year:
                    should_reset = True
                    new_start_time = datetime(now.year, now.month, now.day - now.weekday(), 0, 0, 0)
                    # print("周循环reset：", should_reset)
            elif task["task_type"] == "月循环":
                # 如果不在同一月，则需要重置
                # print("月循环：", start_time.month)
                # print("今月：", now.month)
                if start_time.month != now.month or start_time.year != now.year:
                    should_reset = True
                    new_start_time = datetime(now.year, now.month, 1, 0, 0, 0)
                    # print("月循环reset：", should_reset)
            elif task["task_type"] == "年循环":
                # 如果不在同一年，则需要重置
                if start_time.year != now.year:
                    should_reset = True
                    new_start_time = datetime(now.year, 1, 1, 0, 0, 0)
            # 如果需要重置，则建立任务拷贝，并更新拷贝的任务状态
            if should_reset:
                # 若循环任务完成过则创建副本，以副本形式分离出已完成任务
                if task["completed_count"]>0:
                    # 创建任务副本
                    task_copy = task.copy()  # 复制原任务的所有属性
                    # 更新副本的ID，确保唯一性
                    new_id = max([t["id"] for t in data["tasks"]], default=0) + 1
                    task_copy["id"] = new_id
                    # 更新字段状态
                    task_copy["task_type"] = "无循环"
                    task_copy["total_completion_count"] = task_copy["completed_count"]
                    if not task_copy["complete_time"] in task_copy:
                        # 完成时间不存在则补全
                        task_copy["complete_time"] = now.strftime("%Y-%m-%d %H:%M:%S")
                    task_copy["status"] = "已完成"
                    task_copy['archived'] = True
                    # 保存副本到任务列表
                    data["tasks"].append(task_copy)

                # 刷新原任务的状态
                task["start_time"] = new_start_time.strftime("%Y-%m-%d %H:%M:%S")
                task["completed_count"] = 0
                task["status"] = "未完成"
                task["archived"] = False
                if "complete_time" in task:
                    del task["complete_time"]

                # 更新数+1
                updated_count += 1

    if updated_count > 0 and safe_save_data(data):
        print(f"已更新{updated_count}个循环任务")

    return updated_count


# 添加定时任务线程
def schedule_daily_tasks():
    """定时执行每日任务"""
    while True:
        now = datetime.now()
        # 计算明天凌晨1点的时间
        next_run = now.replace(hour=1, minute=0, second=0, microsecond=0) + timedelta(days=1)
        if now.hour >= 1:
            next_run = next_run.replace(day=next_run.day)

        # 等待到下次执行时间
        time_to_wait = (next_run - now).total_seconds()
        time.sleep(time_to_wait)

        # 执行批量归档
        batch_archive_tasks()

        # 执行刷新循环任务
        check_and_update_cycle_tasks()
        #refresh_cycle_tasks()

# 在应用启动时启动定时任务
# def start_scheduled_tasks():
#     """启动定时任务"""
#     thread = threading.Thread(target=schedule_daily_tasks)
#     thread.daemon = True
#     thread.start()


@app.route('/api/proxy/image', methods=['POST'])
def proxy_image():
    """图片代理接口，用于解决跨域问题"""
    try:
        data = request.json
        image_url = data.get('url')

        if not image_url:
            return jsonify({"error": "缺少图片URL"}), 400

        # 设置请求头，模拟浏览器访问
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }

        # 获取图片
        response = requests.get(image_url, headers=headers, timeout=10)
        response.raise_for_status()

        # 检查内容类型
        content_type = response.headers.get('content-type', '')
        if not content_type.startswith('image/'):
            return jsonify({"error": "URL不是有效的图片"}), 400

        # 转换为base64
        image_data = response.content
        base64_encoded = base64.b64encode(image_data).decode('utf-8')
        data_uri = f"data:{content_type};base64,{base64_encoded}"

        return jsonify({"base64": data_uri})

    except requests.exceptions.RequestException as e:
        return jsonify({"error": f"获取图片失败: {str(e)}"}), 500
    except Exception as e:
        return jsonify({"error": f"处理图片失败: {str(e)}"}), 500


# 在其他API路由之后添加文件管理API路由
@app.route('/api/files/tree', methods=['GET'])
@token_required(optional=True)
def get_file_tree():
    """获取文件树结构"""
    tree = load_file_tree()
    return jsonify(tree)


@app.route('/api/files', methods=['POST'])
def create_file_or_folder():
    """创建文件或文件夹"""
    try:
        data = request.json
        parent_id = data.get('parentId')
        name = data.get('name')
        node_type = data.get('type', 'file')
        content = data.get('content', '') if node_type == 'file' else None

        if not parent_id or not name:
            return jsonify({"error": "缺少必要参数"}), 400

        # 生成新的ID
        new_id = f"{node_type}_{int(datetime.now().timestamp() * 1000)}"

        # 创建节点数据
        new_node = {
            "id": new_id,
            "name": name,
            "type": node_type,
            "createdAt": datetime.now().isoformat(),
            "updatedAt": datetime.now().isoformat()
        }

        if node_type == 'file':
            new_node["content"] = content
            # 保存文件内容到磁盘
            save_file_content(new_id, content if content else "")
        else:
            new_node["children"] = []

        # 添加到文件树
        tree = load_file_tree()

        def add_node(nodes):
            for node in nodes:
                if node["id"] == parent_id:
                    if node["type"] == "folder":
                        node["children"].append(new_node)
                        node["updatedAt"] = datetime.now().isoformat()
                        return True
                elif node["type"] == "folder" and "children" in node:
                    if add_node(node["children"]):
                        node["updatedAt"] = datetime.now().isoformat()
                        return True
            return False

        add_node(tree)
        save_file_tree(tree)

        return jsonify(new_node), 201

    except Exception as e:
        print(f"创建文件或文件夹失败: {str(e)}")
        return jsonify({"error": "创建失败"}), 500


@app.route('/api/files/<file_id>', methods=['GET'])
def get_file_content(file_id):
    """获取文件内容"""
    try:
        content = load_file_content(file_id)
        return jsonify({"content": content})
    except Exception as e:
        print(f"获取文件内容失败: {str(e)}")
        return jsonify({"error": "获取文件内容失败"}), 500


@app.route('/api/files/<file_id>', methods=['PUT'])
def update_file(file_id):
    """更新文件或文件夹"""
    try:
        data = request.json
        tree = load_file_tree()

        def update_node(nodes):
            for node in nodes:
                if node["id"] == file_id:
                    # 更新名称
                    if "name" in data:
                        node["name"] = data["name"]

                    # 更新文件内容
                    if "content" in data and node["type"] == "file":
                        node["content"] = data["content"]
                        save_file_content(file_id, data["content"])

                    node["updatedAt"] = datetime.now().isoformat()
                    return True
                elif node["type"] == "folder" and "children" in node:
                    if update_node(node["children"]):
                        node["updatedAt"] = datetime.now().isoformat()
                        return True
            return False

        if update_node(tree):
            save_file_tree(tree)
            return jsonify({"message": "更新成功"})
        else:
            return jsonify({"error": "文件或文件夹不存在"}), 404

    except Exception as e:
        print(f"更新文件失败: {str(e)}")
        return jsonify({"error": "更新失败"}), 500


@app.route('/api/files/<file_id>', methods=['DELETE'])
def delete_file(file_id):
    """删除文件或文件夹"""
    try:
        tree = load_file_tree()

        def remove_node(nodes):
            for i, node in enumerate(nodes):
                if node["id"] == file_id:
                    # 删除文件内容
                    if node["type"] == "file":
                        delete_file_content(file_id)
                    # 如果是文件夹，递归删除所有子文件
                    elif node["type"] == "folder" and "children" in node:
                        def delete_children(children):
                            for child in children:
                                if child["type"] == "file":
                                    delete_file_content(child["id"])
                                elif child["type"] == "folder" and "children" in child:
                                    delete_children(child["children"])

                        delete_children(node.get("children", []))

                    nodes.pop(i)
                    return True
                elif node["type"] == "folder" and "children" in node:
                    if remove_node(node["children"]):
                        return True
            return False

        if remove_node(tree):
            save_file_tree(tree)
            return jsonify({"message": "删除成功"})
        else:
            return jsonify({"error": "文件或文件夹不存在"}), 404

    except Exception as e:
        print(f"删除文件失败: {str(e)}")
        return jsonify({"error": "删除失败"}), 500


@app.route('/api/load-markdown-file/<file_id>', methods=['GET'])
def load_markdown_file(file_id):
    """加载Markdown文件内容"""
    try:
        file_path = get_journal_path(file_id)
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            return jsonify({'content': content}), 200
        else:
            # 文件不存在，返回空内容
            return jsonify({'content': ''}), 200
    except Exception as e:
        print(f"加载文件失败: {str(e)}")
        return jsonify({'error': '加载文件失败'}), 500


@app.route('/api/save-markdown-file', methods=['POST'])
def save_markdown_file():
    """保存Markdown文件内容"""
    try:
        data = request.get_json()
        file_id = data.get('fileId')
        content = data.get('content')

        if not file_id or content is None:
            return jsonify({'error': '缺少必要参数'}), 400

        file_path = get_journal_path(file_id)

        # 确保目录存在
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)

        return jsonify({'message': '保存成功'}), 200
    except Exception as e:
        print(f"保存文件失败: {str(e)}")
        return jsonify({'error': '保存文件失败'}), 500




@app.route('/api/tasks/refresh-cycle', methods=['POST'])
def refresh_cycle_tasks():
    """手动刷新循环任务"""
    try:
        updated_count = check_and_update_cycle_tasks()
        return jsonify({"message": f"成功刷新{updated_count}个循环任务", "updated_count": updated_count}), 200
    except Exception as e:
        return jsonify({"error": f"刷新失败: {str(e)}"}), 500

# 批量归档API端点
@app.route('/api/tasks/batch-archive', methods=['POST'])
def batch_archive_tasks_api():
    """API端点：批量归档已完成的任务"""
    try:
        updated_count = batch_archive_tasks()
        return jsonify({
            "message": f"成功归档{updated_count}个任务",
            "archived_count": updated_count
        }), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500



@app.route('/api/auto-tasks/execute', methods=['POST'])
def execute_auto_tasks_manually():
    """手动触发执行自动任务"""
    try:
        execute_daily_auto_tasks()
        return jsonify({"message": "自动任务执行完成"}), 200
    except Exception as e:
        return jsonify({"error": f"执行自动任务失败: {str(e)}"}), 500


@app.route('/api/auto-tasks/status', methods=['GET'])
def get_auto_tasks_status():
    """获取自动任务状态"""
    try:
        auto_task_log = get_auto_task_status()
        current_date = date.today().isoformat()

        return jsonify({
            "last_archive_date": auto_task_log.get("last_archive_date"),
            "last_recycle_date": auto_task_log.get("last_recycle_date"),
            "today": current_date,
            "archive_executed_today": auto_task_log.get("last_archive_date") == current_date,
            "recycle_executed_today": auto_task_log.get("last_recycle_date") == current_date
        }), 200
    except Exception as e:
        return jsonify({"error": f"获取自动任务状态失败: {str(e)}"}), 500


@app.route('/api/jnl/check/<date_str>', methods=['GET'])
def check_daily_log_exists(date_str):
    """检查指定日期的日志文件是否存在"""
    try:
        # 构造日志文件名
        log_filename = f"jnl_{date_str}.md"
        log_file_path = os.path.join(config_manager.JOURNALS_DIR, log_filename)

        # 检查文件是否存在
        exists = os.path.exists(log_file_path)

        return jsonify({
            "exists": exists,
            "filename": log_filename,
            "filepath": log_file_path,
            "date": date_str
        })
    except Exception as e:
        print(f"检查日志文件时出错: {str(e)}")
        return jsonify({"error": f"检查日志文件失败: {str(e)}"}), 500


@app.route('/api/jnl/list', methods=['GET'])
def list_daily_logs():
    """获取所有日志文件列表"""
    try:
        log_files = []
        if os.path.exists(config_manager.JOURNALS_DIR):
            # 遍历文件夹，查找所有以jnl_开头的.md文件
            for filename in os.listdir(config_manager.JOURNALS_DIR):
                if filename.startswith('jnl_') and filename.endswith('.md'):
                    # 提取日期部分 (jnl_YYYY-MM-DD.md)
                    date_part = filename[4:-3]  # 去掉'jnl_'前缀和'.md'后缀
                    log_files.append(date_part)

        return jsonify({
            "logs": log_files,
            "count": len(log_files)
        })
    except Exception as e:
        print(f"获取日志文件列表时出错: {str(e)}")
        return jsonify({"error": f"获取日志文件列表失败: {str(e)}"}), 500


@app.route('/api/jnl/delete/<filename_str>', methods=['DELETE'])
def delete_daily_log(filename_str):
    """删除指定文件名的文件"""
    try:
        log_filename = filename_str
        log_file_path = os.path.join(config_manager.JOURNALS_DIR, log_filename)

        # 检查文件是否存在
        if not os.path.exists(log_file_path):
            return jsonify({"error": "文件不存在"}), 404

        # 删除文件
        os.remove(log_file_path)

        return jsonify({
            "message": f"文件 {log_filename} 已删除",
            "filename": log_filename,
            # "date": date_str
        })
    except Exception as e:
        print(f"删除文件时出错: {str(e)}")
        return jsonify({"error": f"删除文件失败: {str(e)}"}), 500


# 图片处理api #
@app.route('/api/files/upload-image', methods=['POST'])
def upload_image():
    """上传图片文件"""
    try:
        if 'image' not in request.files:
            return jsonify({"error": "没有上传文件"}), 400

        file = request.files['image']
        if file.filename == '':
            return jsonify({"error": "未选择文件"}), 400

        if file:
            # 生成安全的文件名
            filename = file.filename
            name, ext = os.path.splitext(filename)
            if not ext:
                ext = '.png'
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            unique_filename = f"img_{timestamp}_{uuid.uuid4().hex[:4]}{ext}"

            # 保存文件
            file_path = os.path.join(config_manager.IMAGES_DIR, unique_filename)
            file.save(file_path)

            # 返回完整的图片URL（相对于前端的访问路径）
            image_url = f"/files/images/{unique_filename}"
            return jsonify({
                "url": image_url,
                "filename": unique_filename
            }), 200

    except Exception as e:
        print(f"上传图片失败: {str(e)}")
        return jsonify({"error": f"上传图片失败: {str(e)}"}), 500

@app.route('/api/files/images', methods=['GET'])
def get_images_list():
    """获取图片文件列表"""
    try:
        images = []
        if os.path.exists(config_manager.IMAGES_DIR):
            for filename in os.listdir(config_manager.IMAGES_DIR):
                file_path = os.path.join(config_manager.IMAGES_DIR, filename)
                if os.path.isfile(file_path) and filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif')):
                    stat = os.stat(file_path)
                    images.append({
                        "name": filename,
                        "size": stat.st_size,
                        "createdAt": datetime.fromtimestamp(stat.st_ctime).isoformat(),
                        "updatedAt": datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
        return jsonify(images)
    except Exception as e:
        print(f"获取图片列表失败: {str(e)}")
        return jsonify([]), 500


@app.route('/api/files/images/unused', methods=['GET'])
def get_unused_images():
    """获取未使用的图片文件列表"""
    try:
        images = get_all_image_files()
        used_images = get_used_images_in_notes()

        unused_images = [img for img in images if img["name"] not in used_images]
        return jsonify({"images": unused_images}), 200
    except Exception as e:
        print(f"获取未使用图片列表失败: {str(e)}")
        return jsonify({"error": f"获取未使用图片列表失败: {str(e)}"}), 500


@app.route('/api/files/images/<filename>', methods=['DELETE'])
def delete_image(filename):
    """删除指定图片文件"""
    try:
        file_path = os.path.join(config_manager.IMAGES_DIR, filename)
        if os.path.exists(file_path):
            os.remove(file_path)
            return jsonify({"message": f"图片 {filename} 已删除"}), 200
        else:
            return jsonify({"error": "图片文件不存在"}), 404
    except Exception as e:
        print(f"删除图片失败: {str(e)}")
        return jsonify({"error": f"删除图片失败: {str(e)}"}), 500


@app.route('/api/files/images/delete-unused', methods=['DELETE'])
def delete_unused_images():
    """删除所有未使用的图片文件"""
    try:
        used_images = get_used_images_in_notes()
        deleted_count = 0

        if os.path.exists(config_manager.IMAGES_DIR):
            for filename in os.listdir(config_manager.IMAGES_DIR):
                if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                    if filename not in used_images:
                        file_path = os.path.join(config_manager.IMAGES_DIR, filename)
                        os.remove(file_path)
                        deleted_count += 1

        return jsonify({
            "message": f"已删除 {deleted_count} 个未使用的图片文件",
            "deleted_count": deleted_count
        }), 200
    except Exception as e:
        print(f"删除未使用图片失败: {str(e)}")
        return jsonify({"error": f"删除未使用图片失败: {str(e)}"}), 500


# 添加静态文件路由以提供图片访问
@app.route('/files/images/<filename>')
def serve_image(filename):
    """提供图片文件访问"""
    try:
        return send_from_directory(config_manager.IMAGES_DIR, filename)
    except Exception as e:
        print(f"提供图片文件失败: {str(e)}")
        return jsonify({"error": "文件不存在"}), 404


@app.route('/api/files/journals', methods=['GET'])
def get_journals_list():
    """获取日志文件列表"""
    try:
        journals = []
        if os.path.exists(config_manager.JOURNALS_DIR):  # 确保 JOURNALS_DIR 已定义
            for filename in os.listdir(config_manager.JOURNALS_DIR):
                file_path = os.path.join(config_manager.JOURNALS_DIR, filename)
                if os.path.isfile(file_path) and filename.endswith('.md'):
                    stat = os.stat(file_path)
                    journals.append({
                        "name": filename,
                        "size": stat.st_size,
                        "createdAt": datetime.fromtimestamp(stat.st_ctime).isoformat(),
                        "updatedAt": datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
        return jsonify(journals)
    except Exception as e:
        print(f"获取日志列表失败: {str(e)}")
        return jsonify([]), 500

@app.route('/api/files/journal/<filename>', methods=['GET'])
def get_journal_content(filename):
    """获取日志文件内容"""
    try:
        file_path = os.path.join(config_manager.JOURNALS_DIR, filename)
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            return jsonify({
                "content": content,
                "filename": filename,
                "size": os.path.getsize(file_path),
                "createdAt": datetime.fromtimestamp(os.path.getctime(file_path)).isoformat(),
                "updatedAt": datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat()
            })
        else:
            return jsonify({"error": "文件不存在"}), 404
    except Exception as e:
        print(f"读取日志文件失败: {str(e)}")
        return jsonify({"error": f"读取文件失败: {str(e)}"}), 500


@app.route('/api/files/journal/<filename>', methods=['DELETE'])
def delete_journal_file(filename):
    """删除日志文件"""
    try:
        file_path = os.path.join(config_manager.JOURNALS_DIR, filename)
        if os.path.exists(file_path):
            os.remove(file_path)
            return jsonify({"message": f"日志文件 {filename} 已删除"})
        else:
            return jsonify({"error": "文件不存在"}), 404
    except Exception as e:
        print(f"删除日志文件失败: {str(e)}")
        return jsonify({"error": f"删除文件失败: {str(e)}"}), 500


@app.route('/api/files/journals/batch-delete', methods=['POST'])
def batch_delete_journal_files():
    """批量删除日志文件"""
    try:
        data = request.json
        file_names = data.get('fileNames', [])

        deleted_files = []
        errors = []

        for filename in file_names:
            file_path = os.path.join(config_manager.JOURNALS_DIR, filename)
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    deleted_files.append(filename)
                else:
                    errors.append(f"文件 {filename} 不存在")
            except Exception as e:
                errors.append(f"删除文件 {filename} 失败: {str(e)}")

        if errors:
            return jsonify({
                "message": f"成功删除 {len(deleted_files)} 个文件",
                "deleted_files": deleted_files,
                "errors": errors
            }), 207  # Multi-Status
        else:
            return jsonify({
                "message": f"成功删除 {len(deleted_files)} 个文件",
                "deleted_files": deleted_files
            })
    except Exception as e:
        print(f"批量删除日志文件失败: {str(e)}")
        return jsonify({"error": f"批量删除文件失败: {str(e)}"}), 500

@app.route('/api/files/images/batch-delete', methods=['POST'])
def batch_delete_images():
    """批量删除图片文件"""
    try:
        data = request.json
        file_names = data.get('fileNames', [])

        deleted_files = []
        errors = []

        for filename in file_names:
            file_path = os.path.join(config_manager.IMAGES_DIR, filename)
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    deleted_files.append(filename)
                else:
                    errors.append(f"文件 {filename} 不存在")
            except Exception as e:
                errors.append(f"删除文件 {filename} 失败: {str(e)}")

        if errors:
            return jsonify({
                "message": f"成功删除 {len(deleted_files)} 个文件",
                "deleted_files": deleted_files,
                "errors": errors
            }), 207  # Multi-Status
        else:
            return jsonify({
                "message": f"成功删除 {len(deleted_files)} 个文件",
                "deleted_files": deleted_files
            })
    except Exception as e:
        print(f"批量删除图片文件失败: {str(e)}")
        return jsonify({"error": f"批量删除文件失败: {str(e)}"}), 500

@app.route('/api/files/image/<filename>', methods=['DELETE'])
def delete_image_file(filename):
    """删除图片文件"""
    try:
        file_path = os.path.join(config_manager.IMAGES_DIR, filename)
        if os.path.exists(file_path):
            os.remove(file_path)
            return jsonify({"message": f"图片文件 {filename} 已删除"})
        else:
            return jsonify({"error": "文件不存在"}), 404
    except Exception as e:
        print(f"删除图片文件失败: {str(e)}")
        return jsonify({"error": f"删除文件失败: {str(e)}"}), 500



@app.route('/api/files/<file_id>/move', methods=['PUT'])
def move_file(file_id):
    """移动文件或文件夹到指定目标文件夹"""
    try:
        data = request.json
        target_folder_id = data.get('targetFolderId')

        if not target_folder_id:
            return jsonify({"error": "缺少目标文件夹ID"}), 400

        # 加载文件树
        file_tree = load_file_tree()

        # 查找源文件/文件夹
        source_node = find_node_in_tree(file_tree, file_id)
        if not source_node:
            return jsonify({"error": "源文件或文件夹不存在"}), 404

        # 查找目标文件夹
        target_folder = find_node_in_tree(file_tree, target_folder_id)
        if not target_folder or target_folder["type"] != "folder":
            return jsonify({"error": "目标文件夹不存在或不是文件夹"}), 400

        # 检查是否尝试将文件夹移动到自身或其子文件夹中
        if source_node["type"] == "folder":
            if target_folder_id == file_id:
                return jsonify({"error": "不能将文件夹移动到自身"}), 400

            # 检查目标是否是源的子文件夹
            if is_descendant_of(target_folder, source_node):
                return jsonify({"error": "不能将文件夹移动到其子文件夹中"}), 400

        # 从原位置移除
        remove_node_from_tree(file_tree, file_id)

        # 添加到新位置
        target_folder["children"].append(source_node)

        # 保存更新后的文件树
        if save_file_tree(file_tree):
            return jsonify({"message": "移动成功"}), 200
        else:
            return jsonify({"error": "保存文件树失败"}), 500

    except Exception as e:
        print(f"移动文件时出错: {str(e)}")
        return jsonify({"error": f"移动文件失败: {str(e)}"}), 500

def find_node_in_tree(nodes, node_id):
    """在文件树中查找指定ID的节点"""
    for node in nodes:
        if node["id"] == node_id:
            return node
        if node["type"] == "folder" and "children" in node:
            found = find_node_in_tree(node["children"], node_id)
            if found:
                return found
    return None

def remove_node_from_tree(nodes, node_id):
    """从文件树中移除指定ID的节点"""
    for i, node in enumerate(nodes):
        if node["id"] == node_id:
            return nodes.pop(i)
        if node["type"] == "folder" and "children" in node:
            removed = remove_node_from_tree(node["children"], node_id)
            if removed:
                return removed
    return None

def is_descendant_of(target_folder, source_folder):
    """检查目标文件夹是否是源文件夹的后代（用于防止循环引用）"""
    # 如果目标文件夹就是源文件夹，返回True（防止移动到自身）
    if target_folder["id"] == source_folder["id"]:
        return True

    # 如果目标不是文件夹，返回False
    if target_folder["type"] != "folder":
        return False

    # 递归检查目标文件夹的所有父级路径
    # 这里需要一个辅助函数来查找目标文件夹在文件树中的路径

    # 简化实现：如果无法确定完整路径，可以只检查直接包含关系
    return False


@app.route('/api/settings/toolbar', methods=['POST'])
def update_toolbar_settings():
    """更新工具栏设置"""
    try:
        # 获取请求数据
        new_settings = request.json

        # 加载现有设置
        settings = load_settings()

        # 更新工具栏设置
        settings['toolbarSettings'] = new_settings

        # 保存设置
        if save_settings(settings):
            return jsonify({
                "message": "工具栏设置已更新",
                "settings": new_settings
            })
        else:
            return jsonify({"error": "保存设置失败"}), 500

    except Exception as e:
        print(f"更新工具栏设置时出错: {str(e)}")
        return jsonify({"error": f"更新工具栏设置失败: {str(e)}"}), 500


@app.route('/api/settings/toolbar', methods=['GET'])
def get_toolbar_settings():
    """获取工具栏设置"""
    try:
        # 加载设置
        settings = load_settings()

        # 获取工具栏设置，如果没有则返回默认设置
        toolbar_settings = settings.get('toolbarSettings', {
            "buttons": [
                {"id": "position", "type": "control", "visible": True},
                {"id": "list", "type": "view", "visible": True},
                {"id": "board", "type": "view", "visible": True},
                {"id": "calendar", "type": "view", "visible": True},
                {"id": "card", "type": "view", "visible": True},
                {"id": "scale", "type": "control", "visible": True},
                {"id": "hide", "type": "control", "visible": True},
                {"id": "logs", "type": "control", "visible": True},
                {"id": "quick", "type": "control", "visible": True},
                {"id": "refresh", "type": "control", "visible": True}
            ]
        })

        return jsonify(toolbar_settings)

    except Exception as e:
        print(f"获取工具栏设置时出错: {str(e)}")
        return jsonify({"error": f"获取工具栏设置失败: {str(e)}"}), 500

if __name__ == '__main__':
    # env, debug = get_app_config()

    # if env == 'production':
    #     print("警告: 这是开发服务器，不应用于生产环境")
    #     print("请使用 Gunicorn 或其他 WSGI 服务器")

    # 开发模式启动
    app.run(host='0.0.0.0', port=5000, debug=True)
